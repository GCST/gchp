! $Id: ESMF_FieldSetCo.cppF90,v 1.16.2.1 2010/02/05 19:56:10 svasquez Exp $
!
! Earth System Modeling Framework
! Copyright 2002-2010, University Corporation for Atmospheric Research,
! Massachusetts Institute of Technology, Geophysical Fluid Dynamics
! Laboratory, University of Michigan, National Centers for Environmental
! Prediction, Los Alamos National Laboratory, Argonne National Laboratory,
! NASA Goddard Space Flight Center.
! Licensed under the University of Illinois-NCSA License.
!
!==============================================================================
#define ESMF_FILENAME "ESMF_FieldSetCo.F90"
!==============================================================================
!
! ESMF FieldSetCo module
module ESMF_FieldSetCoMod
!
!==============================================================================
!
! This file contains the FieldSet() methods.
!
!------------------------------------------------------------------------------
! INCLUDES
! < ignore blank lines below. they are created by the files which
! define various macros. >
#include "ESMF.h"


!------------------------------------------------------------------------------
! !USES:
  use ESMF_UtilTypesMod
  use ESMF_BaseMod
  use ESMF_LogErrMod
  use ESMF_LocalArrayMod
  use ESMF_DistGridMod
  use ESMF_StaggerLocMod
  use ESMF_GridMod
  use ESMF_MeshMod
  use ESMF_LocStreamMod
  use ESMF_GeomBaseMod
  use ESMF_ArrayMod
  use ESMF_ArrayCreateMod
  use ESMF_InitMacrosMod

  use ESMF_FieldMod

  implicit none

!------------------------------------------------------------------------------
! !PRIVATE TYPES:
  private

!------------------------------------------------------------------------------
! !PUBLIC MEMBER FUNCTIONS:

  public ESMF_FieldSetCommit

!------------------------------------------------------------------------------
! The following line turns the CVS identifier string into a printable variable.
  character(*), parameter, private :: version = &
    '$Id: ESMF_FieldSetCo.cppF90,v 1.16.2.1 2010/02/05 19:56:10 svasquez Exp $'

!==============================================================================
!
! INTERFACE BLOCKS
!
!==============================================================================


!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_FieldSetCommit - Finishes a Field started with FieldCreateEmpty
!
! !INTERFACE:
  interface ESMF_FieldSetCommit

! !PRIVATE MEMBER FUNCTIONS:
!
    !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldSetCommitGrid1DI1 
 module procedure ESMF_FieldSetCommitGrid2DI1 
 module procedure ESMF_FieldSetCommitGrid3DI1 
 module procedure ESMF_FieldSetCommitGrid4DI1 
#ifndef ESMF_NO_GREATER_THAN_4D 
 module procedure ESMF_FieldSetCommitGrid5DI1 
 module procedure ESMF_FieldSetCommitGrid6DI1 
 module procedure ESMF_FieldSetCommitGrid7DI1 
#endif 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldSetCommitGrid1DI2 
 module procedure ESMF_FieldSetCommitGrid2DI2 
 module procedure ESMF_FieldSetCommitGrid3DI2 
 module procedure ESMF_FieldSetCommitGrid4DI2 
#ifndef ESMF_NO_GREATER_THAN_4D 
 module procedure ESMF_FieldSetCommitGrid5DI2 
 module procedure ESMF_FieldSetCommitGrid6DI2 
 module procedure ESMF_FieldSetCommitGrid7DI2 
#endif 
#endif 
 module procedure ESMF_FieldSetCommitGrid1DI4 
 module procedure ESMF_FieldSetCommitGrid1DI8 
 module procedure ESMF_FieldSetCommitGrid1DR4 
 module procedure ESMF_FieldSetCommitGrid1DR8 
 module procedure ESMF_FieldSetCommitGrid2DI4 
 module procedure ESMF_FieldSetCommitGrid2DI8 
 module procedure ESMF_FieldSetCommitGrid2DR4 
 module procedure ESMF_FieldSetCommitGrid2DR8 
 module procedure ESMF_FieldSetCommitGrid3DI4 
 module procedure ESMF_FieldSetCommitGrid3DI8 
 module procedure ESMF_FieldSetCommitGrid3DR4 
 module procedure ESMF_FieldSetCommitGrid3DR8 
 module procedure ESMF_FieldSetCommitGrid4DI4 
 module procedure ESMF_FieldSetCommitGrid4DI8 
 module procedure ESMF_FieldSetCommitGrid4DR4 
 module procedure ESMF_FieldSetCommitGrid4DR8 
#ifndef ESMF_NO_GREATER_THAN_4D 
 module procedure ESMF_FieldSetCommitGrid5DI4 
 module procedure ESMF_FieldSetCommitGrid5DI8 
 module procedure ESMF_FieldSetCommitGrid5DR4 
 module procedure ESMF_FieldSetCommitGrid5DR8 
 module procedure ESMF_FieldSetCommitGrid6DI4 
 module procedure ESMF_FieldSetCommitGrid6DI8 
 module procedure ESMF_FieldSetCommitGrid6DR4 
 module procedure ESMF_FieldSetCommitGrid6DR8 
 module procedure ESMF_FieldSetCommitGrid7DI4 
 module procedure ESMF_FieldSetCommitGrid7DI8 
 module procedure ESMF_FieldSetCommitGrid7DR4 
 module procedure ESMF_FieldSetCommitGrid7DR8 
#endif 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

    !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldSetCommitGridPtr1DI1 
 module procedure ESMF_FieldSetCommitGridPtr2DI1 
 module procedure ESMF_FieldSetCommitGridPtr3DI1 
 module procedure ESMF_FieldSetCommitGridPtr4DI1 
#ifndef ESMF_NO_GREATER_THAN_4D 
 module procedure ESMF_FieldSetCommitGridPtr5DI1 
 module procedure ESMF_FieldSetCommitGridPtr6DI1 
 module procedure ESMF_FieldSetCommitGridPtr7DI1 
#endif 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldSetCommitGridPtr1DI2 
 module procedure ESMF_FieldSetCommitGridPtr2DI2 
 module procedure ESMF_FieldSetCommitGridPtr3DI2 
 module procedure ESMF_FieldSetCommitGridPtr4DI2 
#ifndef ESMF_NO_GREATER_THAN_4D 
 module procedure ESMF_FieldSetCommitGridPtr5DI2 
 module procedure ESMF_FieldSetCommitGridPtr6DI2 
 module procedure ESMF_FieldSetCommitGridPtr7DI2 
#endif 
#endif 
 module procedure ESMF_FieldSetCommitGridPtr1DI4 
 module procedure ESMF_FieldSetCommitGridPtr1DI8 
 module procedure ESMF_FieldSetCommitGridPtr1DR4 
 module procedure ESMF_FieldSetCommitGridPtr1DR8 
 module procedure ESMF_FieldSetCommitGridPtr2DI4 
 module procedure ESMF_FieldSetCommitGridPtr2DI8 
 module procedure ESMF_FieldSetCommitGridPtr2DR4 
 module procedure ESMF_FieldSetCommitGridPtr2DR8 
 module procedure ESMF_FieldSetCommitGridPtr3DI4 
 module procedure ESMF_FieldSetCommitGridPtr3DI8 
 module procedure ESMF_FieldSetCommitGridPtr3DR4 
 module procedure ESMF_FieldSetCommitGridPtr3DR8 
 module procedure ESMF_FieldSetCommitGridPtr4DI4 
 module procedure ESMF_FieldSetCommitGridPtr4DI8 
 module procedure ESMF_FieldSetCommitGridPtr4DR4 
 module procedure ESMF_FieldSetCommitGridPtr4DR8 
#ifndef ESMF_NO_GREATER_THAN_4D 
 module procedure ESMF_FieldSetCommitGridPtr5DI4 
 module procedure ESMF_FieldSetCommitGridPtr5DI8 
 module procedure ESMF_FieldSetCommitGridPtr5DR4 
 module procedure ESMF_FieldSetCommitGridPtr5DR8 
 module procedure ESMF_FieldSetCommitGridPtr6DI4 
 module procedure ESMF_FieldSetCommitGridPtr6DI8 
 module procedure ESMF_FieldSetCommitGridPtr6DR4 
 module procedure ESMF_FieldSetCommitGridPtr6DR8 
 module procedure ESMF_FieldSetCommitGridPtr7DI4 
 module procedure ESMF_FieldSetCommitGridPtr7DI8 
 module procedure ESMF_FieldSetCommitGridPtr7DR4 
 module procedure ESMF_FieldSetCommitGridPtr7DR8 
#endif 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

    !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldSetCommitLS1DI1 
 module procedure ESMF_FieldSetCommitLS2DI1 
 module procedure ESMF_FieldSetCommitLS3DI1 
 module procedure ESMF_FieldSetCommitLS4DI1 
#ifndef ESMF_NO_GREATER_THAN_4D 
 module procedure ESMF_FieldSetCommitLS5DI1 
 module procedure ESMF_FieldSetCommitLS6DI1 
 module procedure ESMF_FieldSetCommitLS7DI1 
#endif 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldSetCommitLS1DI2 
 module procedure ESMF_FieldSetCommitLS2DI2 
 module procedure ESMF_FieldSetCommitLS3DI2 
 module procedure ESMF_FieldSetCommitLS4DI2 
#ifndef ESMF_NO_GREATER_THAN_4D 
 module procedure ESMF_FieldSetCommitLS5DI2 
 module procedure ESMF_FieldSetCommitLS6DI2 
 module procedure ESMF_FieldSetCommitLS7DI2 
#endif 
#endif 
 module procedure ESMF_FieldSetCommitLS1DI4 
 module procedure ESMF_FieldSetCommitLS1DI8 
 module procedure ESMF_FieldSetCommitLS1DR4 
 module procedure ESMF_FieldSetCommitLS1DR8 
 module procedure ESMF_FieldSetCommitLS2DI4 
 module procedure ESMF_FieldSetCommitLS2DI8 
 module procedure ESMF_FieldSetCommitLS2DR4 
 module procedure ESMF_FieldSetCommitLS2DR8 
 module procedure ESMF_FieldSetCommitLS3DI4 
 module procedure ESMF_FieldSetCommitLS3DI8 
 module procedure ESMF_FieldSetCommitLS3DR4 
 module procedure ESMF_FieldSetCommitLS3DR8 
 module procedure ESMF_FieldSetCommitLS4DI4 
 module procedure ESMF_FieldSetCommitLS4DI8 
 module procedure ESMF_FieldSetCommitLS4DR4 
 module procedure ESMF_FieldSetCommitLS4DR8 
#ifndef ESMF_NO_GREATER_THAN_4D 
 module procedure ESMF_FieldSetCommitLS5DI4 
 module procedure ESMF_FieldSetCommitLS5DI8 
 module procedure ESMF_FieldSetCommitLS5DR4 
 module procedure ESMF_FieldSetCommitLS5DR8 
 module procedure ESMF_FieldSetCommitLS6DI4 
 module procedure ESMF_FieldSetCommitLS6DI8 
 module procedure ESMF_FieldSetCommitLS6DR4 
 module procedure ESMF_FieldSetCommitLS6DR8 
 module procedure ESMF_FieldSetCommitLS7DI4 
 module procedure ESMF_FieldSetCommitLS7DI8 
 module procedure ESMF_FieldSetCommitLS7DR4 
 module procedure ESMF_FieldSetCommitLS7DR8 
#endif 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

    !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldSetCommitLSPtr1DI1 
 module procedure ESMF_FieldSetCommitLSPtr2DI1 
 module procedure ESMF_FieldSetCommitLSPtr3DI1 
 module procedure ESMF_FieldSetCommitLSPtr4DI1 
#ifndef ESMF_NO_GREATER_THAN_4D 
 module procedure ESMF_FieldSetCommitLSPtr5DI1 
 module procedure ESMF_FieldSetCommitLSPtr6DI1 
 module procedure ESMF_FieldSetCommitLSPtr7DI1 
#endif 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldSetCommitLSPtr1DI2 
 module procedure ESMF_FieldSetCommitLSPtr2DI2 
 module procedure ESMF_FieldSetCommitLSPtr3DI2 
 module procedure ESMF_FieldSetCommitLSPtr4DI2 
#ifndef ESMF_NO_GREATER_THAN_4D 
 module procedure ESMF_FieldSetCommitLSPtr5DI2 
 module procedure ESMF_FieldSetCommitLSPtr6DI2 
 module procedure ESMF_FieldSetCommitLSPtr7DI2 
#endif 
#endif 
 module procedure ESMF_FieldSetCommitLSPtr1DI4 
 module procedure ESMF_FieldSetCommitLSPtr1DI8 
 module procedure ESMF_FieldSetCommitLSPtr1DR4 
 module procedure ESMF_FieldSetCommitLSPtr1DR8 
 module procedure ESMF_FieldSetCommitLSPtr2DI4 
 module procedure ESMF_FieldSetCommitLSPtr2DI8 
 module procedure ESMF_FieldSetCommitLSPtr2DR4 
 module procedure ESMF_FieldSetCommitLSPtr2DR8 
 module procedure ESMF_FieldSetCommitLSPtr3DI4 
 module procedure ESMF_FieldSetCommitLSPtr3DI8 
 module procedure ESMF_FieldSetCommitLSPtr3DR4 
 module procedure ESMF_FieldSetCommitLSPtr3DR8 
 module procedure ESMF_FieldSetCommitLSPtr4DI4 
 module procedure ESMF_FieldSetCommitLSPtr4DI8 
 module procedure ESMF_FieldSetCommitLSPtr4DR4 
 module procedure ESMF_FieldSetCommitLSPtr4DR8 
#ifndef ESMF_NO_GREATER_THAN_4D 
 module procedure ESMF_FieldSetCommitLSPtr5DI4 
 module procedure ESMF_FieldSetCommitLSPtr5DI8 
 module procedure ESMF_FieldSetCommitLSPtr5DR4 
 module procedure ESMF_FieldSetCommitLSPtr5DR8 
 module procedure ESMF_FieldSetCommitLSPtr6DI4 
 module procedure ESMF_FieldSetCommitLSPtr6DI8 
 module procedure ESMF_FieldSetCommitLSPtr6DR4 
 module procedure ESMF_FieldSetCommitLSPtr6DR8 
 module procedure ESMF_FieldSetCommitLSPtr7DI4 
 module procedure ESMF_FieldSetCommitLSPtr7DI8 
 module procedure ESMF_FieldSetCommitLSPtr7DR4 
 module procedure ESMF_FieldSetCommitLSPtr7DR8 
#endif 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

    !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldSetCommitMesh1DI1 
 module procedure ESMF_FieldSetCommitMesh2DI1 
 module procedure ESMF_FieldSetCommitMesh3DI1 
 module procedure ESMF_FieldSetCommitMesh4DI1 
#ifndef ESMF_NO_GREATER_THAN_4D 
 module procedure ESMF_FieldSetCommitMesh5DI1 
 module procedure ESMF_FieldSetCommitMesh6DI1 
 module procedure ESMF_FieldSetCommitMesh7DI1 
#endif 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldSetCommitMesh1DI2 
 module procedure ESMF_FieldSetCommitMesh2DI2 
 module procedure ESMF_FieldSetCommitMesh3DI2 
 module procedure ESMF_FieldSetCommitMesh4DI2 
#ifndef ESMF_NO_GREATER_THAN_4D 
 module procedure ESMF_FieldSetCommitMesh5DI2 
 module procedure ESMF_FieldSetCommitMesh6DI2 
 module procedure ESMF_FieldSetCommitMesh7DI2 
#endif 
#endif 
 module procedure ESMF_FieldSetCommitMesh1DI4 
 module procedure ESMF_FieldSetCommitMesh1DI8 
 module procedure ESMF_FieldSetCommitMesh1DR4 
 module procedure ESMF_FieldSetCommitMesh1DR8 
 module procedure ESMF_FieldSetCommitMesh2DI4 
 module procedure ESMF_FieldSetCommitMesh2DI8 
 module procedure ESMF_FieldSetCommitMesh2DR4 
 module procedure ESMF_FieldSetCommitMesh2DR8 
 module procedure ESMF_FieldSetCommitMesh3DI4 
 module procedure ESMF_FieldSetCommitMesh3DI8 
 module procedure ESMF_FieldSetCommitMesh3DR4 
 module procedure ESMF_FieldSetCommitMesh3DR8 
 module procedure ESMF_FieldSetCommitMesh4DI4 
 module procedure ESMF_FieldSetCommitMesh4DI8 
 module procedure ESMF_FieldSetCommitMesh4DR4 
 module procedure ESMF_FieldSetCommitMesh4DR8 
#ifndef ESMF_NO_GREATER_THAN_4D 
 module procedure ESMF_FieldSetCommitMesh5DI4 
 module procedure ESMF_FieldSetCommitMesh5DI8 
 module procedure ESMF_FieldSetCommitMesh5DR4 
 module procedure ESMF_FieldSetCommitMesh5DR8 
 module procedure ESMF_FieldSetCommitMesh6DI4 
 module procedure ESMF_FieldSetCommitMesh6DI8 
 module procedure ESMF_FieldSetCommitMesh6DR4 
 module procedure ESMF_FieldSetCommitMesh6DR8 
 module procedure ESMF_FieldSetCommitMesh7DI4 
 module procedure ESMF_FieldSetCommitMesh7DI8 
 module procedure ESMF_FieldSetCommitMesh7DR4 
 module procedure ESMF_FieldSetCommitMesh7DR8 
#endif 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

    !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldSetCommitMeshPtr1DI1 
 module procedure ESMF_FieldSetCommitMeshPtr2DI1 
 module procedure ESMF_FieldSetCommitMeshPtr3DI1 
 module procedure ESMF_FieldSetCommitMeshPtr4DI1 
#ifndef ESMF_NO_GREATER_THAN_4D 
 module procedure ESMF_FieldSetCommitMeshPtr5DI1 
 module procedure ESMF_FieldSetCommitMeshPtr6DI1 
 module procedure ESMF_FieldSetCommitMeshPtr7DI1 
#endif 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldSetCommitMeshPtr1DI2 
 module procedure ESMF_FieldSetCommitMeshPtr2DI2 
 module procedure ESMF_FieldSetCommitMeshPtr3DI2 
 module procedure ESMF_FieldSetCommitMeshPtr4DI2 
#ifndef ESMF_NO_GREATER_THAN_4D 
 module procedure ESMF_FieldSetCommitMeshPtr5DI2 
 module procedure ESMF_FieldSetCommitMeshPtr6DI2 
 module procedure ESMF_FieldSetCommitMeshPtr7DI2 
#endif 
#endif 
 module procedure ESMF_FieldSetCommitMeshPtr1DI4 
 module procedure ESMF_FieldSetCommitMeshPtr1DI8 
 module procedure ESMF_FieldSetCommitMeshPtr1DR4 
 module procedure ESMF_FieldSetCommitMeshPtr1DR8 
 module procedure ESMF_FieldSetCommitMeshPtr2DI4 
 module procedure ESMF_FieldSetCommitMeshPtr2DI8 
 module procedure ESMF_FieldSetCommitMeshPtr2DR4 
 module procedure ESMF_FieldSetCommitMeshPtr2DR8 
 module procedure ESMF_FieldSetCommitMeshPtr3DI4 
 module procedure ESMF_FieldSetCommitMeshPtr3DI8 
 module procedure ESMF_FieldSetCommitMeshPtr3DR4 
 module procedure ESMF_FieldSetCommitMeshPtr3DR8 
 module procedure ESMF_FieldSetCommitMeshPtr4DI4 
 module procedure ESMF_FieldSetCommitMeshPtr4DI8 
 module procedure ESMF_FieldSetCommitMeshPtr4DR4 
 module procedure ESMF_FieldSetCommitMeshPtr4DR8 
#ifndef ESMF_NO_GREATER_THAN_4D 
 module procedure ESMF_FieldSetCommitMeshPtr5DI4 
 module procedure ESMF_FieldSetCommitMeshPtr5DI8 
 module procedure ESMF_FieldSetCommitMeshPtr5DR4 
 module procedure ESMF_FieldSetCommitMeshPtr5DR8 
 module procedure ESMF_FieldSetCommitMeshPtr6DI4 
 module procedure ESMF_FieldSetCommitMeshPtr6DI8 
 module procedure ESMF_FieldSetCommitMeshPtr6DR4 
 module procedure ESMF_FieldSetCommitMeshPtr6DR8 
 module procedure ESMF_FieldSetCommitMeshPtr7DI4 
 module procedure ESMF_FieldSetCommitMeshPtr7DI8 
 module procedure ESMF_FieldSetCommitMeshPtr7DR4 
 module procedure ESMF_FieldSetCommitMeshPtr7DR8 
#endif 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

    !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldSetCommitGB1DI1 
 module procedure ESMF_FieldSetCommitGB2DI1 
 module procedure ESMF_FieldSetCommitGB3DI1 
 module procedure ESMF_FieldSetCommitGB4DI1 
#ifndef ESMF_NO_GREATER_THAN_4D 
 module procedure ESMF_FieldSetCommitGB5DI1 
 module procedure ESMF_FieldSetCommitGB6DI1 
 module procedure ESMF_FieldSetCommitGB7DI1 
#endif 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldSetCommitGB1DI2 
 module procedure ESMF_FieldSetCommitGB2DI2 
 module procedure ESMF_FieldSetCommitGB3DI2 
 module procedure ESMF_FieldSetCommitGB4DI2 
#ifndef ESMF_NO_GREATER_THAN_4D 
 module procedure ESMF_FieldSetCommitGB5DI2 
 module procedure ESMF_FieldSetCommitGB6DI2 
 module procedure ESMF_FieldSetCommitGB7DI2 
#endif 
#endif 
 module procedure ESMF_FieldSetCommitGB1DI4 
 module procedure ESMF_FieldSetCommitGB1DI8 
 module procedure ESMF_FieldSetCommitGB1DR4 
 module procedure ESMF_FieldSetCommitGB1DR8 
 module procedure ESMF_FieldSetCommitGB2DI4 
 module procedure ESMF_FieldSetCommitGB2DI8 
 module procedure ESMF_FieldSetCommitGB2DR4 
 module procedure ESMF_FieldSetCommitGB2DR8 
 module procedure ESMF_FieldSetCommitGB3DI4 
 module procedure ESMF_FieldSetCommitGB3DI8 
 module procedure ESMF_FieldSetCommitGB3DR4 
 module procedure ESMF_FieldSetCommitGB3DR8 
 module procedure ESMF_FieldSetCommitGB4DI4 
 module procedure ESMF_FieldSetCommitGB4DI8 
 module procedure ESMF_FieldSetCommitGB4DR4 
 module procedure ESMF_FieldSetCommitGB4DR8 
#ifndef ESMF_NO_GREATER_THAN_4D 
 module procedure ESMF_FieldSetCommitGB5DI4 
 module procedure ESMF_FieldSetCommitGB5DI8 
 module procedure ESMF_FieldSetCommitGB5DR4 
 module procedure ESMF_FieldSetCommitGB5DR8 
 module procedure ESMF_FieldSetCommitGB6DI4 
 module procedure ESMF_FieldSetCommitGB6DI8 
 module procedure ESMF_FieldSetCommitGB6DR4 
 module procedure ESMF_FieldSetCommitGB6DR8 
 module procedure ESMF_FieldSetCommitGB7DI4 
 module procedure ESMF_FieldSetCommitGB7DI8 
 module procedure ESMF_FieldSetCommitGB7DR4 
 module procedure ESMF_FieldSetCommitGB7DR8 
#endif 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

    !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldSetCommitGBPtr1DI1 
 module procedure ESMF_FieldSetCommitGBPtr2DI1 
 module procedure ESMF_FieldSetCommitGBPtr3DI1 
 module procedure ESMF_FieldSetCommitGBPtr4DI1 
#ifndef ESMF_NO_GREATER_THAN_4D 
 module procedure ESMF_FieldSetCommitGBPtr5DI1 
 module procedure ESMF_FieldSetCommitGBPtr6DI1 
 module procedure ESMF_FieldSetCommitGBPtr7DI1 
#endif 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldSetCommitGBPtr1DI2 
 module procedure ESMF_FieldSetCommitGBPtr2DI2 
 module procedure ESMF_FieldSetCommitGBPtr3DI2 
 module procedure ESMF_FieldSetCommitGBPtr4DI2 
#ifndef ESMF_NO_GREATER_THAN_4D 
 module procedure ESMF_FieldSetCommitGBPtr5DI2 
 module procedure ESMF_FieldSetCommitGBPtr6DI2 
 module procedure ESMF_FieldSetCommitGBPtr7DI2 
#endif 
#endif 
 module procedure ESMF_FieldSetCommitGBPtr1DI4 
 module procedure ESMF_FieldSetCommitGBPtr1DI8 
 module procedure ESMF_FieldSetCommitGBPtr1DR4 
 module procedure ESMF_FieldSetCommitGBPtr1DR8 
 module procedure ESMF_FieldSetCommitGBPtr2DI4 
 module procedure ESMF_FieldSetCommitGBPtr2DI8 
 module procedure ESMF_FieldSetCommitGBPtr2DR4 
 module procedure ESMF_FieldSetCommitGBPtr2DR8 
 module procedure ESMF_FieldSetCommitGBPtr3DI4 
 module procedure ESMF_FieldSetCommitGBPtr3DI8 
 module procedure ESMF_FieldSetCommitGBPtr3DR4 
 module procedure ESMF_FieldSetCommitGBPtr3DR8 
 module procedure ESMF_FieldSetCommitGBPtr4DI4 
 module procedure ESMF_FieldSetCommitGBPtr4DI8 
 module procedure ESMF_FieldSetCommitGBPtr4DR4 
 module procedure ESMF_FieldSetCommitGBPtr4DR8 
#ifndef ESMF_NO_GREATER_THAN_4D 
 module procedure ESMF_FieldSetCommitGBPtr5DI4 
 module procedure ESMF_FieldSetCommitGBPtr5DI8 
 module procedure ESMF_FieldSetCommitGBPtr5DR4 
 module procedure ESMF_FieldSetCommitGBPtr5DR8 
 module procedure ESMF_FieldSetCommitGBPtr6DI4 
 module procedure ESMF_FieldSetCommitGBPtr6DI8 
 module procedure ESMF_FieldSetCommitGBPtr6DR4 
 module procedure ESMF_FieldSetCommitGBPtr6DR8 
 module procedure ESMF_FieldSetCommitGBPtr7DI4 
 module procedure ESMF_FieldSetCommitGBPtr7DI8 
 module procedure ESMF_FieldSetCommitGBPtr7DR4 
 module procedure ESMF_FieldSetCommitGBPtr7DR8 
#endif 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 


! !DESCRIPTION:
! This interface finishes a {\tt ESMF\_Field} started with FieldCreateEmpty
! These methods all take {\tt ESMF\_Grid} and Fortran data array or pointer as input to
! fill in the {\tt ESMF\_Field} internals.
  end interface
!EOPI
!------------------------------------------------------------------------------


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

contains

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!---------------------------------------------------------------------------- 
!BOP 
! !IROUTINE: ESMF_FieldSetCommit - Finishes creating Field from Grid started with FieldCreateEmpty 
! 
! !INTERFACE: 
! ! Private name; call using ESMF_FieldSetCommit() 
! subroutine ESMF_FieldSetCommitGrid<rank><type><kind>(field, grid, & 
! farray, indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
! ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 
! 
! !ARGUMENTS: 
! type(ESMF_Field), intent(inout) :: field 
! type(ESMF_Grid), intent(in) :: grid 
! <type> (ESMF_KIND_<kind>), dimension(<rank>), target :: farray 
! type(ESMF_IndexFlag), intent(in) :: indexflag 
! type(ESMF_CopyFlag), intent(in), optional :: copyflag 
! type(ESMF_STAGGERLOC), intent(in), optional :: staggerloc 
! integer, intent(in), optional :: gridToFieldMap(:) 
! integer, intent(in), optional :: ungriddedLBound(:) 
! integer, intent(in), optional :: ungriddedUBound(:) 
! integer, intent(in), optional :: maxHaloLWidth(:) 
! integer, intent(in), optional :: maxHaloUWidth(:) 
! integer, intent(inout), optional :: rc 
! 
! !DESCRIPTION: 
! This call completes an {\tt ESMF\_Field} allocated with the 
! {\tt ESMF\_FieldCreateEmpty()} call. For an example and 
! associated documentation using this method see Section 
! \ref{sec:field:usage:create_empty_setcommit}. 
! 
! The fortran data pointer inside {\tt ESMF\_Field} can be queried but deallocating 
! the retrieved data pointer is not allowed. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! The {\tt ESMF\_Field} object to be completed and 
! committed in this call. The {\tt field} will have the same dimension 
! (dimCount) as the rank of the {\tt farray}. 
! \item [grid] 
! The {\tt ESMF\_Grid} object to finish the Field. 
! \item [farray] 
! Native fortran data array to be copied/referenced in the {\tt field}. 
! The {\tt field} dimension (dimCount) will be the same as the dimCount 
! for the {\tt farray}. 
! \item [indexflag] 
! Indicate how DE-local indices are defined. See section 
! \ref{opt:indexflag} for a list of valid indexflag options. 
! \item [{[copyflag]}] 
! Indicates whether to copy the {\tt farray} or reference it directly. 
! For valid values see \ref{opt:copyflag}. The default is 
! {\tt ESMF\_DATA\_REF}. 
! \item [{[staggerloc]}] 
! Stagger location of data in grid cells. For valid 
! predefined values see Section \ref{sec:opt:staggerloc}. 
! To create a custom stagger location see Section 
! \ref{sec:usage:staggerloc:adv}. The default 
! value is {\tt ESMF\_STAGGERLOC\_CENTER}. 
! \item [{[gridToFieldMap]}] 
! List with number of elements equal to the 
! {\tt grid}'s dimCount. The list elements map each dimension 
! of the {\tt grid} to a dimension in the {\tt farray} by 
! specifying the appropriate {\tt farray} dimension index. The 
! default is to map all of the {\tt grid}'s dimensions against the 
! lowest dimensions of the {\tt farray} in sequence, i.e. 
! {\tt gridToFieldMap} = (/1,2,3,.../). 
! Unmapped {\tt farray} dimensions are undistributed Field 
! dimensions. 
! All {\tt gridToFieldMap} entries must be greater than or equal 
! to zero and smaller than or equal to the Field dimCount. It is erroneous 
! to specify the same entry multiple times unless it is zero. 
! If the Field dimCount is less than the Grid dimCount then the default 
! gridToFieldMap will contain zeros for the rightmost entries. A zero 
! entry in the {\tt gridToFieldMap} indicates that the particular 
! Grid dimension will be replicating the Field across the DEs along 
! this direction. 
! \item [{[ungriddedLBound]}] 
! Lower bounds of the ungridded dimensions of the {\tt field}. 
! The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded 
! dimensions in the {\tt field}. All ungridded dimensions of the 
! {\tt field} are also undistributed. When field dimension count is 
! greater than grid dimension count, both ungriddedLBound and ungriddedUBound 
! must be specified. When both are specified the values are checked 
! for consistency. Note that the the ordering of 
! these ungridded dimensions is the same as their order in the {\tt field}. 
! \item [{[ungriddedUBound]}] 
! Upper bounds of the ungridded dimensions of the {\tt field}. 
! The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded 
! dimensions in the {\tt field}. All ungridded dimensions of the 
! {\tt field} are also undistributed. When field dimension count is 
! greater than grid dimension count, both ungriddedLBound and ungriddedUBound 
! must be specified. When both are specified the values are checked 
! for consistency. Note that the the ordering of 
! these ungridded dimensions is the same as their order in the {\tt field}. 
! \item [{[maxHaloLWidth]}] 
! Lower bound of halo region. The size of this array is the number 
! of gridded dimensions in the {\tt field}. However, ordering of the elements 
! needs to be the same as they appear in the {\tt field}. Values default 
! to 0. If values for maxHaloLWidth are specified they must be reflected in 
! the size of the {\tt field}. That is, for each gridded dimension the 
! {\tt field} size should be max( {\tt maxHaloLWidth} + {\tt maxHaloUWidth} 
! + {\tt computationalCount}, {\tt exclusiveCount} ). Although the halo operation is not 
! implemented, the {\tt minHaloLWidth} is checked for validity and stored 
! in preparation for the implementation of the halo method. 
! HALO OPERATION NOT IMPLEMENTED 
! \item [{[maxHaloUWidth]}] 
! Upper bound of halo region. The size of this array is the number 
! of gridded dimensions in the {\tt field}. However, ordering of the elements 
! needs to be the same as they appear in the {\tt field}. Values default 
! to 0. If values for maxHaloUWidth are specified they must be reflected in 
! the size of the {\tt field}. That is, for each gridded dimension the 
! {\tt field} size should max( {\tt maxHaloLWidth} + {\tt maxHaloUWidth} 
! + {\tt computationalCount}, {\tt exclusiveCount} ). Although the halo operation is not 
! implemented, the {\tt maxHaloUWidth} is checked for validity and stored 
! in preparation for the implementation of the halo method. 
! HALO OPERATION NOT IMPLEMENTED 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
!EOP 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid1Di1(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i1), dimension(:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB1Di1(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid1Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid2Di1(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i1), dimension(:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB2Di1(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid2Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid3Di1(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i1), dimension(:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB3Di1(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid3Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid4Di1(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i1), dimension(:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB4Di1(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid4Di1 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_GREATER_THAN_4D 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid5Di1(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i1), dimension(:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB5Di1(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid5Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid6Di1(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i1), dimension(:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB6Di1(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid6Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid7Di1(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i1), dimension(:,:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB7Di1(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid7Di1 
!---------------------------------------------------------------------------- 
 
#endif 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid1Di2(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i2), dimension(:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB1Di2(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid1Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid2Di2(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i2), dimension(:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB2Di2(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid2Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid3Di2(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i2), dimension(:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB3Di2(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid3Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid4Di2(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i2), dimension(:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB4Di2(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid4Di2 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_GREATER_THAN_4D 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid5Di2(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i2), dimension(:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB5Di2(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid5Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid6Di2(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i2), dimension(:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB6Di2(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid6Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid7Di2(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i2), dimension(:,:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB7Di2(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid7Di2 
!---------------------------------------------------------------------------- 
 
#endif 
#endif 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid1Di4(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i4), dimension(:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB1Di4(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid1Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid1Di8(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i8), dimension(:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB1Di8(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid1Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid1Dr4(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 real (ESMF_KIND_r4), dimension(:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB1Dr4(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid1Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid1Dr8(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 real (ESMF_KIND_r8), dimension(:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB1Dr8(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid1Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid2Di4(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i4), dimension(:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB2Di4(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid2Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid2Di8(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i8), dimension(:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB2Di8(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid2Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid2Dr4(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 real (ESMF_KIND_r4), dimension(:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB2Dr4(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid2Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid2Dr8(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 real (ESMF_KIND_r8), dimension(:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB2Dr8(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid2Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid3Di4(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i4), dimension(:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB3Di4(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid3Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid3Di8(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i8), dimension(:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB3Di8(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid3Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid3Dr4(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 real (ESMF_KIND_r4), dimension(:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB3Dr4(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid3Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid3Dr8(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 real (ESMF_KIND_r8), dimension(:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB3Dr8(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid3Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid4Di4(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i4), dimension(:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB4Di4(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid4Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid4Di8(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i8), dimension(:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB4Di8(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid4Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid4Dr4(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 real (ESMF_KIND_r4), dimension(:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB4Dr4(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid4Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid4Dr8(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 real (ESMF_KIND_r8), dimension(:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB4Dr8(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid4Dr8 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_GREATER_THAN_4D 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid5Di4(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i4), dimension(:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB5Di4(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid5Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid5Di8(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i8), dimension(:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB5Di8(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid5Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid5Dr4(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 real (ESMF_KIND_r4), dimension(:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB5Dr4(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid5Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid5Dr8(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 real (ESMF_KIND_r8), dimension(:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB5Dr8(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid5Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid6Di4(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i4), dimension(:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB6Di4(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid6Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid6Di8(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i8), dimension(:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB6Di8(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid6Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid6Dr4(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 real (ESMF_KIND_r4), dimension(:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB6Dr4(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid6Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid6Dr8(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 real (ESMF_KIND_r8), dimension(:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB6Dr8(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid6Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid7Di4(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i4), dimension(:,:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB7Di4(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid7Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid7Di8(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i8), dimension(:,:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB7Di8(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid7Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid7Dr4(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 real (ESMF_KIND_r4), dimension(:,:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB7Dr4(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid7Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGrid" 
 subroutine ESMF_FieldSetCommitGrid7Dr8(field, grid, farray, & 
 indexflag, copyflag, staggerloc, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 real (ESMF_KIND_r8), dimension(:,:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid, localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB7Dr8(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGrid7Dr8 
!---------------------------------------------------------------------------- 
 
#endif 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!---------------------------------------------------------------------------- 
!BOP 
! !IROUTINE: ESMF_FieldSetCommit - Finishes creating Field from Grid started with FieldCreateEmpty 
! 
! !INTERFACE: 
! ! Private name; call using ESMF_FieldSetCommit() 
! subroutine ESMF_FieldSetCommitGridPtr<rank><type><kind>(field, grid, & 
! farrayPtr, copyflag, staggerloc, gridToFieldMap, & 
! maxHaloLWidth, maxHaloUWidth, rc) 
! 
! !ARGUMENTS: 
! type(ESMF_Field), intent(inout) :: field 
! type(ESMF_Grid), intent(in) :: grid 
! <type> (ESMF_KIND_<kind>), dimension(<rank>), pointer :: farrayPtr 
! type(ESMF_CopyFlag), intent(in), optional :: copyflag 
! type(ESMF_STAGGERLOC), intent(in), optional :: staggerloc 
! integer, intent(in), optional :: gridToFieldMap(:) 
! integer, intent(in), optional :: maxHaloLWidth(:) 
! integer, intent(in), optional :: maxHaloUWidth(:) 
! integer, intent(inout), optional :: rc 
! 
! !DESCRIPTION: 
! This call completes an {\tt ESMF\_Field} allocated with the 
! {\tt ESMF\_FieldCreateEmpty()} call. For an example and 
! associated documentation using this method see Section 
! \ref{sec:field:usage:create_empty_setcommit}. 
! 
! The fortran data pointer inside {\tt ESMF\_Field} can be queried and deallocated when 
! copyflag is {\tt ESMF\_DATA\_REF}. Note that the {\tt ESMF\_FieldDestroy} call does not deallocate 
! the fortran data pointer in this case. This gives user more flexibility over memory management. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! The {\tt ESMF\_Field} object to be completed and 
! committed in this call. The {\tt field} will have the same dimension 
! (dimCount) as the rank of the {\tt farrayPtr}. 
! \item [grid] 
! The {\tt ESMF\_Grid} object to finish the Field. 
! \item [farrayPtr] 
! Native fortran data pointer to be copied/referenced in the {\tt field}. 
! The {\tt field} dimension (dimCount) will be the same as the dimCount 
! for the {\tt farrayPtr}. 
! \item [{[copyflag]}] 
! Indicates whether to copy the {\tt farrayPtr} or reference it directly. 
! For valid values see \ref{opt:copyflag}. The default is 
! {\tt ESMF\_DATA\_REF}. 
! \item [{[staggerloc]}] 
! Stagger location of data in grid cells. For valid 
! predefined values see Section \ref{sec:opt:staggerloc}. 
! To create a custom stagger location see Section 
! \ref{sec:usage:staggerloc:adv}. The default 
! value is {\tt ESMF\_STAGGERLOC\_CENTER}. 
! \item [{[gridToFieldMap]}] 
! List with number of elements equal to the 
! {\tt grid}'s dimCount. The list elements map each dimension 
! of the {\tt grid} to a dimension in the {\tt farrayPtr} by 
! specifying the appropriate {\tt farrayPtr} dimension index. The 
! default is to map all of the {\tt grid}'s dimensions against the 
! lowest dimensions of the {\tt farrayPtr} in sequence, i.e. 
! {\tt gridToFieldMap} = (/1,2,3,.../). 
! Unmapped {\tt farrayPtr} dimensions are undistributed Field 
! dimensions. 
! All {\tt gridToFieldMap} entries must be greater than or equal 
! to zero and smaller than or equal to the Field dimCount. It is erroneous 
! to specify the same entry multiple times unless it is zero. 
! If the Field dimCount is less than the Grid dimCount then the default 
! gridToFieldMap will contain zeros for the rightmost entries. A zero 
! entry in the {\tt gridToFieldMap} indicates that the particular 
! Grid dimension will be replicating the Field across the DEs along 
! this direction. 
! \item [{[maxHaloLWidth]}] 
! Lower bound of halo region. The size of this array is the number 
! of gridded dimensions in the {\tt field}. However, ordering of the elements 
! needs to be the same as they appear in the {\tt field}. Values default 
! to 0. If values for maxHaloLWidth are specified they must be reflected in 
! the size of the {\tt field}. That is, for each gridded dimension the 
! {\tt field} size should be max( {\tt maxHaloLWidth} + {\tt maxHaloUWidth} 
! + {\tt computationalCount}, {\tt exclusiveCount} ). Although the halo operation is not 
! implemented, the {\tt minHaloLWidth} is checked for validity and stored 
! in preparation for the implementation of the halo method. 
! HALO OPERATION NOT IMPLEMENTED 
! \item [{[maxHaloUWidth]}] 
! Upper bound of halo region. The size of this array is the number 
! of gridded dimensions in the {\tt field}. However, ordering of the elements 
! needs to be the same as they appear in the {\tt field}. Values default 
! to 0. If values for maxHaloUWidth are specified they must be reflected in 
! the size of the {\tt field}. That is, for each gridded dimension the 
! {\tt field} size should max( {\tt maxHaloLWidth} + {\tt maxHaloUWidth} 
! + {\tt computationalCount}, {\tt exclusiveCount} ). Although the halo operation is not 
! implemented, the {\tt maxHaloUWidth} is checked for validity and stored 
! in preparation for the implementation of the halo method. 
! HALO OPERATION NOT IMPLEMENTED 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
!EOP 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr1Di1(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i1), dimension(:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr1Di1(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr1Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr2Di1(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i1), dimension(:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr2Di1(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr2Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr3Di1(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i1), dimension(:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr3Di1(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr3Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr4Di1(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i1), dimension(:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr4Di1(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr4Di1 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_GREATER_THAN_4D 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr5Di1(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i1), dimension(:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr5Di1(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr5Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr6Di1(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i1), dimension(:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr6Di1(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr6Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr7Di1(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i1), dimension(:,:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr7Di1(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr7Di1 
!---------------------------------------------------------------------------- 
 
#endif 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr1Di2(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i2), dimension(:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr1Di2(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr1Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr2Di2(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i2), dimension(:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr2Di2(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr2Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr3Di2(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i2), dimension(:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr3Di2(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr3Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr4Di2(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i2), dimension(:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr4Di2(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr4Di2 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_GREATER_THAN_4D 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr5Di2(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i2), dimension(:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr5Di2(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr5Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr6Di2(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i2), dimension(:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr6Di2(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr6Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr7Di2(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i2), dimension(:,:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr7Di2(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr7Di2 
!---------------------------------------------------------------------------- 
 
#endif 
#endif 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr1Di4(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i4), dimension(:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr1Di4(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr1Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr1Di8(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i8), dimension(:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr1Di8(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr1Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr1Dr4(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 real (ESMF_KIND_r4), dimension(:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr1Dr4(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr1Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr1Dr8(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 real (ESMF_KIND_r8), dimension(:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr1Dr8(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr1Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr2Di4(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i4), dimension(:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr2Di4(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr2Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr2Di8(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i8), dimension(:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr2Di8(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr2Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr2Dr4(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 real (ESMF_KIND_r4), dimension(:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr2Dr4(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr2Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr2Dr8(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 real (ESMF_KIND_r8), dimension(:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr2Dr8(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr2Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr3Di4(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i4), dimension(:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr3Di4(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr3Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr3Di8(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i8), dimension(:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr3Di8(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr3Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr3Dr4(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 real (ESMF_KIND_r4), dimension(:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr3Dr4(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr3Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr3Dr8(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 real (ESMF_KIND_r8), dimension(:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr3Dr8(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr3Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr4Di4(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i4), dimension(:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr4Di4(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr4Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr4Di8(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i8), dimension(:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr4Di8(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr4Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr4Dr4(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 real (ESMF_KIND_r4), dimension(:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr4Dr4(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr4Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr4Dr8(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 real (ESMF_KIND_r8), dimension(:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr4Dr8(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr4Dr8 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_GREATER_THAN_4D 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr5Di4(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i4), dimension(:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr5Di4(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr5Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr5Di8(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i8), dimension(:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr5Di8(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr5Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr5Dr4(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 real (ESMF_KIND_r4), dimension(:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr5Dr4(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr5Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr5Dr8(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 real (ESMF_KIND_r8), dimension(:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr5Dr8(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr5Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr6Di4(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i4), dimension(:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr6Di4(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr6Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr6Di8(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i8), dimension(:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr6Di8(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr6Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr6Dr4(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 real (ESMF_KIND_r4), dimension(:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr6Dr4(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr6Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr6Dr8(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 real (ESMF_KIND_r8), dimension(:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr6Dr8(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr6Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr7Di4(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i4), dimension(:,:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr7Di4(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr7Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr7Di8(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 integer (ESMF_KIND_i8), dimension(:,:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr7Di8(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr7Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr7Dr4(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 real (ESMF_KIND_r4), dimension(:,:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr7Dr4(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr7Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGridPtr" 
 subroutine ESMF_FieldSetCommitGridPtr7Dr8(field, grid, farrayPtr, & 
 copyflag, staggerloc, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Grid) :: grid 
 real (ESMF_KIND_r8), dimension(:,:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 type(ESMF_StaggerLoc), intent(in), optional ::staggerloc 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 type(ESMF_StaggerLoc) :: localStaggerLoc 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 
 type(ESMF_GridDecompType) :: decompType 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 

 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (decompType .eq. ESMF_GRID_ARBITRARY) then 
 if ((present(maxHaloLWidth)) .or. (present(maxHaloUWidth))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- indexflag, maxHaloLWidth or maxHaloUWidth are not allowed for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Set default values. 
 if (present(staggerloc)) then 
 if ((decompType .eq. ESMF_GRID_ARBITRARY) .and. & 
 (staggerloc .ne. ESMF_STAGGERLOC_CENTER)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "- staggerloc has to be ESMF_STAGGERLOC_CENTER for arbitrary grid", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 localStaggerloc=staggerloc 
 endif 
 else 
 localStaggerLoc = ESMF_STAGGERLOC_CENTER 
 endif 

 geombase=ESMF_GeomBaseCreate(grid,localStaggerloc, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr7Dr8(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 ! link the Attribute hierarchies 
 call c_ESMC_AttributeLink(field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGridPtr7Dr8 
!---------------------------------------------------------------------------- 
 
#endif 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!---------------------------------------------------------------------------- 
!BOP 
! !IROUTINE: ESMF_FieldSetCommit - Finishes creating Field from LocStream started with FieldCreateEmpty 
! 
! !INTERFACE: 
! ! Private name; call using ESMF_FieldSetCommit() 
! subroutine ESMF_FieldSetCommitLS<rank><type><kind>(field, locstream, & 
! farray, indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
! ungriddedUBound, rc) 
! 
! !ARGUMENTS: 
! type(ESMF_Field), intent(inout) :: field 
! type(ESMF_LocStream), intent(in) :: locstream 
! <type> (ESMF_KIND_<kind>), dimension(<rank>), target :: farray 
! type(ESMF_IndexFlag), intent(in) :: indexflag 
! type(ESMF_CopyFlag), intent(in), optional :: copyflag 
! integer, intent(in), optional :: gridToFieldMap(:) 
! integer, intent(in), optional :: ungriddedLBound(:) 
! integer, intent(in), optional :: ungriddedUBound(:) 
! integer, intent(inout), optional :: rc 
! 
! !DESCRIPTION: 
! This call completes an {\tt ESMF\_Field} allocated with the 
! {\tt ESMF\_FieldCreateEmpty()} call. For an example and 
! associated documentation using this method see Section 
! \ref{sec:field:usage:create_empty_setcommit}. 
! 
! The fortran data pointer inside {\tt ESMF\_Field} can be queried but deallocating 
! the retrieved data pointer is not allowed. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! The {\tt ESMF\_Field} object to be completed and 
! committed in this call. The {\tt field} will have the same dimension 
! (dimCount) as the rank of the {\tt farray}. 
! \item [locstream] 
! The {\tt ESMF\_LocStream} object to finish the Field. 
! \item [farray] 
! Native fortran data array to be copied/referenced in the {\tt field}. 
! The {\tt field} dimension (dimCount) will be the same as the dimCount 
! for the {\tt farray}. 
! \item [indexflag] 
! Indicate how DE-local indices are defined. See section 
! \ref{opt:indexflag} for a list of valid indexflag options. 
! \item [{[copyflag]}] 
! Indicates whether to copy the {\tt farray} or reference it directly. 
! For valid values see \ref{opt:copyflag}. The default is 
! {\tt ESMF\_DATA\_REF}. 
! \item [{[gridToFieldMap]}] 
! List with number of elements equal to the 
! {\tt locstream}'s dimCount. The list elements map each dimension 
! of the {\tt locstream} to a dimension in the {\tt farray} by 
! specifying the appropriate {\tt farray} dimension index. The 
! default is to map all of the {\tt locstream}'s dimensions against the 
! lowest dimensions of the {\tt farray} in sequence, i.e. 
! {\tt gridToFieldMap} = (/1,2,3,.../). 
! Unmapped {\tt farray} dimensions are undistributed Field 
! dimensions. 
! All {\tt gridToFieldMap} entries must be greater than or equal 
! to zero and smaller than or equal to the Field dimCount. It is erroneous 
! to specify the same entry multiple times unless it is zero. 
! If the Field dimCount is less than the LocStream dimCount then the default 
! gridToFieldMap will contain zeros for the rightmost entries. A zero 
! entry in the {\tt gridToFieldMap} indicates that the particular 
! LocStream dimension will be replicating the Field across the DEs along 
! this direction. 
! \item [{[ungriddedLBound]}] 
! Lower bounds of the ungridded dimensions of the {\tt field}. 
! The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded 
! dimensions in the {\tt field}. All ungridded dimensions of the 
! {\tt field} are also undistributed. When field dimension count is 
! greater than locstream dimension count, both ungriddedLBound and ungriddedUBound 
! must be specified. When both are specified the values are checked 
! for consistency. Note that the the ordering of 
! these ungridded dimensions is the same as their order in the {\tt field}. 
! \item [{[ungriddedUBound]}] 
! Upper bounds of the ungridded dimensions of the {\tt field}. 
! The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded 
! dimensions in the {\tt field}. All ungridded dimensions of the 
! {\tt field} are also undistributed. When field dimension count is 
! greater than locstream dimension count, both ungriddedLBound and ungriddedUBound 
! must be specified. When both are specified the values are checked 
! for consistency. Note that the the ordering of 
! these ungridded dimensions is the same as their order in the {\tt field}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
!EOP 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS1Di1(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i1), dimension(:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB1Di1(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS1Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS2Di1(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i1), dimension(:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB2Di1(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS2Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS3Di1(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i1), dimension(:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB3Di1(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS3Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS4Di1(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i1), dimension(:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB4Di1(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS4Di1 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_GREATER_THAN_4D 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS5Di1(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i1), dimension(:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB5Di1(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS5Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS6Di1(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i1), dimension(:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB6Di1(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS6Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS7Di1(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i1), dimension(:,:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB7Di1(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS7Di1 
!---------------------------------------------------------------------------- 
 
#endif 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS1Di2(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i2), dimension(:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB1Di2(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS1Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS2Di2(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i2), dimension(:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB2Di2(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS2Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS3Di2(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i2), dimension(:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB3Di2(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS3Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS4Di2(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i2), dimension(:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB4Di2(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS4Di2 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_GREATER_THAN_4D 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS5Di2(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i2), dimension(:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB5Di2(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS5Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS6Di2(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i2), dimension(:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB6Di2(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS6Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS7Di2(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i2), dimension(:,:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB7Di2(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS7Di2 
!---------------------------------------------------------------------------- 
 
#endif 
#endif 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS1Di4(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i4), dimension(:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB1Di4(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS1Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS1Di8(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i8), dimension(:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB1Di8(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS1Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS1Dr4(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 real (ESMF_KIND_r4), dimension(:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB1Dr4(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS1Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS1Dr8(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 real (ESMF_KIND_r8), dimension(:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB1Dr8(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS1Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS2Di4(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i4), dimension(:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB2Di4(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS2Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS2Di8(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i8), dimension(:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB2Di8(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS2Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS2Dr4(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 real (ESMF_KIND_r4), dimension(:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB2Dr4(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS2Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS2Dr8(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 real (ESMF_KIND_r8), dimension(:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB2Dr8(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS2Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS3Di4(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i4), dimension(:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB3Di4(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS3Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS3Di8(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i8), dimension(:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB3Di8(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS3Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS3Dr4(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 real (ESMF_KIND_r4), dimension(:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB3Dr4(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS3Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS3Dr8(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 real (ESMF_KIND_r8), dimension(:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB3Dr8(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS3Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS4Di4(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i4), dimension(:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB4Di4(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS4Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS4Di8(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i8), dimension(:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB4Di8(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS4Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS4Dr4(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 real (ESMF_KIND_r4), dimension(:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB4Dr4(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS4Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS4Dr8(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 real (ESMF_KIND_r8), dimension(:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB4Dr8(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS4Dr8 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_GREATER_THAN_4D 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS5Di4(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i4), dimension(:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB5Di4(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS5Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS5Di8(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i8), dimension(:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB5Di8(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS5Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS5Dr4(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 real (ESMF_KIND_r4), dimension(:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB5Dr4(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS5Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS5Dr8(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 real (ESMF_KIND_r8), dimension(:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB5Dr8(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS5Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS6Di4(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i4), dimension(:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB6Di4(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS6Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS6Di8(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i8), dimension(:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB6Di8(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS6Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS6Dr4(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 real (ESMF_KIND_r4), dimension(:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB6Dr4(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS6Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS6Dr8(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 real (ESMF_KIND_r8), dimension(:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB6Dr8(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS6Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS7Di4(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i4), dimension(:,:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB7Di4(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS7Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS7Di8(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i8), dimension(:,:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB7Di8(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS7Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS7Dr4(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 real (ESMF_KIND_r4), dimension(:,:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB7Dr4(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS7Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLS" 
 subroutine ESMF_FieldSetCommitLS7Dr8(field, locstream, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 real (ESMF_KIND_r8), dimension(:,:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB7Dr8(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLS7Dr8 
!---------------------------------------------------------------------------- 
 
#endif 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!---------------------------------------------------------------------------- 
!BOP 
! !IROUTINE: ESMF_FieldSetCommit - Finishes creating Field from LocStream started with FieldCreateEmpty 
! 
! !INTERFACE: 
! ! Private name; call using ESMF_FieldSetCommit() 
! subroutine ESMF_FieldSetCommitLSPtr<rank><type><kind>(field, locstream, & 
! farrayPtr, copyflag, gridToFieldMap, rc) 
! 
! !ARGUMENTS: 
! type(ESMF_Field), intent(inout) :: field 
! type(ESMF_LocStream), intent(in) :: locstream 
! <type> (ESMF_KIND_<kind>), dimension(<rank>), pointer :: farrayPtr 
! type(ESMF_CopyFlag), intent(in), optional :: copyflag 
! integer, intent(in), optional :: gridToFieldMap(:) 
! integer, intent(inout), optional :: rc 
! 
! !DESCRIPTION: 
! This call completes an {\tt ESMF\_Field} allocated with the 
! {\tt ESMF\_FieldCreateEmpty()} call. For an example and 
! associated documentation using this method see Section 
! \ref{sec:field:usage:create_empty_setcommit}. 
! 
! The fortran data pointer inside {\tt ESMF\_Field} can be queried and deallocated when 
! copyflag is {\tt ESMF\_DATA\_REF}. Note that the {\tt ESMF\_FieldDestroy} call does not deallocate 
! the fortran data pointer in this case. This gives user more flexibility over memory management. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! The {\tt ESMF\_Field} object to be completed and 
! committed in this call. The {\tt field} will have the same dimension 
! (dimCount) as the rank of the {\tt farrayPtr}. 
! \item [locstream] 
! The {\tt ESMF\_LocStream} object to finish the Field. 
! \item [farrayPtr] 
! Native fortran data pointer to be copied/referenced in the {\tt field}. 
! The {\tt field} dimension (dimCount) will be the same as the dimCount 
! for the {\tt farrayPtr}. 
! \item [{[copyflag]}] 
! Indicates whether to copy the {\tt farrayPtr} or reference it directly. 
! For valid values see \ref{opt:copyflag}. The default is 
! {\tt ESMF\_DATA\_REF}. 
! \item [{[gridToFieldMap]}] 
! List with number of elements equal to the 
! {\tt locstream}'s dimCount. The list elements map each dimension 
! of the {\tt locstream} to a dimension in the {\tt farrayPtr} by 
! specifying the appropriate {\tt farrayPtr} dimension index. The 
! default is to map all of the {\tt locstream}'s dimensions against the 
! lowest dimensions of the {\tt farrayPtr} in sequence, i.e. 
! {\tt gridToFieldMap} = (/1,2,3,.../). 
! Unmapped {\tt farrayPtr} dimensions are undistributed Field 
! dimensions. 
! All {\tt gridToFieldMap} entries must be greater than or equal 
! to zero and smaller than or equal to the Field dimCount. It is erroneous 
! to specify the same entry multiple times unless it is zero. 
! If the Field dimCount is less than the LocStream dimCount then the default 
! gridToFieldMap will contain zeros for the rightmost entries. A zero 
! entry in the {\tt gridToFieldMap} indicates that the particular 
! LocStream dimension will be replicating the Field across the DEs along 
! this direction. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
!EOP 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr1Di1(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i1), dimension(:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr1Di1(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr1Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr2Di1(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i1), dimension(:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr2Di1(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr2Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr3Di1(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i1), dimension(:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr3Di1(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr3Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr4Di1(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i1), dimension(:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr4Di1(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr4Di1 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_GREATER_THAN_4D 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr5Di1(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i1), dimension(:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr5Di1(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr5Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr6Di1(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i1), dimension(:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr6Di1(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr6Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr7Di1(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i1), dimension(:,:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr7Di1(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr7Di1 
!---------------------------------------------------------------------------- 
 
#endif 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr1Di2(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i2), dimension(:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr1Di2(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr1Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr2Di2(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i2), dimension(:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr2Di2(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr2Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr3Di2(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i2), dimension(:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr3Di2(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr3Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr4Di2(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i2), dimension(:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr4Di2(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr4Di2 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_GREATER_THAN_4D 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr5Di2(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i2), dimension(:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr5Di2(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr5Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr6Di2(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i2), dimension(:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr6Di2(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr6Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr7Di2(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i2), dimension(:,:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr7Di2(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr7Di2 
!---------------------------------------------------------------------------- 
 
#endif 
#endif 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr1Di4(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i4), dimension(:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr1Di4(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr1Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr1Di8(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i8), dimension(:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr1Di8(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr1Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr1Dr4(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 real (ESMF_KIND_r4), dimension(:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr1Dr4(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr1Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr1Dr8(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 real (ESMF_KIND_r8), dimension(:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr1Dr8(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr1Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr2Di4(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i4), dimension(:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr2Di4(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr2Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr2Di8(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i8), dimension(:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr2Di8(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr2Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr2Dr4(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 real (ESMF_KIND_r4), dimension(:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr2Dr4(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr2Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr2Dr8(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 real (ESMF_KIND_r8), dimension(:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr2Dr8(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr2Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr3Di4(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i4), dimension(:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr3Di4(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr3Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr3Di8(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i8), dimension(:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr3Di8(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr3Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr3Dr4(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 real (ESMF_KIND_r4), dimension(:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr3Dr4(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr3Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr3Dr8(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 real (ESMF_KIND_r8), dimension(:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr3Dr8(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr3Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr4Di4(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i4), dimension(:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr4Di4(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr4Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr4Di8(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i8), dimension(:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr4Di8(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr4Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr4Dr4(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 real (ESMF_KIND_r4), dimension(:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr4Dr4(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr4Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr4Dr8(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 real (ESMF_KIND_r8), dimension(:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr4Dr8(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr4Dr8 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_GREATER_THAN_4D 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr5Di4(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i4), dimension(:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr5Di4(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr5Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr5Di8(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i8), dimension(:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr5Di8(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr5Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr5Dr4(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 real (ESMF_KIND_r4), dimension(:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr5Dr4(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr5Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr5Dr8(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 real (ESMF_KIND_r8), dimension(:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr5Dr8(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr5Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr6Di4(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i4), dimension(:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr6Di4(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr6Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr6Di8(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i8), dimension(:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr6Di8(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr6Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr6Dr4(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 real (ESMF_KIND_r4), dimension(:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr6Dr4(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr6Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr6Dr8(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 real (ESMF_KIND_r8), dimension(:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr6Dr8(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr6Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr7Di4(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i4), dimension(:,:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr7Di4(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr7Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr7Di8(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 integer (ESMF_KIND_i8), dimension(:,:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr7Di8(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr7Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr7Dr4(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 real (ESMF_KIND_r4), dimension(:,:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr7Dr4(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr7Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitLSPtr" 
 subroutine ESMF_FieldSetCommitLSPtr7Dr8(field, locstream, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_LocStream) :: locstream 
 real (ESMF_KIND_r8), dimension(:,:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, locstream, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_LocStreamGetInit,locstream,rc) 

 geombase=ESMF_GeomBaseCreate(locstream,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr7Dr8(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitLSPtr7Dr8 
!---------------------------------------------------------------------------- 
 
#endif 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!---------------------------------------------------------------------------- 
!BOP 
! !IROUTINE: ESMF_FieldSetCommit - Finishes creating Field from Mesh started with FieldCreateEmpty 
! 
! !INTERFACE: 
! ! Private name; call using ESMF_FieldSetCommit() 
! subroutine ESMF_FieldSetCommitMesh<rank><type><kind>(field, mesh, & 
! farray, indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
! ungriddedUBound, rc) 
! 
! !ARGUMENTS: 
! type(ESMF_Field), intent(inout) :: field 
! type(ESMF_Mesh), intent(in) :: mesh 
! <type> (ESMF_KIND_<kind>), dimension(<rank>), target :: farray 
! type(ESMF_IndexFlag), intent(in) :: indexflag 
! type(ESMF_CopyFlag), intent(in), optional :: copyflag 
! integer, intent(in), optional :: gridToFieldMap(:) 
! integer, intent(in), optional :: ungriddedLBound(:) 
! integer, intent(in), optional :: ungriddedUBound(:) 
! integer, intent(inout), optional :: rc 
! 
! !DESCRIPTION: 
! This call completes an {\tt ESMF\_Field} allocated with the 
! {\tt ESMF\_FieldCreateEmpty()} call. For an example and 
! associated documentation using this method see Section 
! \ref{sec:field:usage:create_empty_setcommit}. 
! 
! The fortran data pointer inside {\tt ESMF\_Field} can be queried but deallocating 
! the retrieved data pointer is not allowed. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! The {\tt ESMF\_Field} object to be completed and 
! committed in this call. The {\tt field} will have the same dimension 
! (dimCount) as the rank of the {\tt farray}. 
! \item [mesh] 
! The {\tt ESMF\_Mesh} object to finish the Field. 
! \item [farray] 
! Native fortran data array to be copied/referenced in the {\tt field}. 
! The {\tt field} dimension (dimCount) will be the same as the dimCount 
! for the {\tt farray}. 
! \item [indexflag] 
! Indicate how DE-local indices are defined. See section 
! \ref{opt:indexflag} for a list of valid indexflag options. 
! \item [{[copyflag]}] 
! Indicates whether to copy the {\tt farray} or reference it directly. 
! For valid values see \ref{opt:copyflag}. The default is 
! {\tt ESMF\_DATA\_REF}. 
! \item [{[gridToFieldMap]}] 
! List with number of elements equal to the 
! {\tt mesh}'s dimCount. The list elements map each dimension 
! of the {\tt mesh} to a dimension in the {\tt farray} by 
! specifying the appropriate {\tt farray} dimension index. The 
! default is to map all of the {\tt mesh}'s dimensions against the 
! lowest dimensions of the {\tt farray} in sequence, i.e. 
! {\tt gridToFieldMap} = (/1,2,3,.../). 
! Unmapped {\tt farray} dimensions are undistributed Field 
! dimensions. 
! All {\tt gridToFieldMap} entries must be greater than or equal 
! to zero and smaller than or equal to the Field dimCount. It is erroneous 
! to specify the same entry multiple times unless it is zero. 
! If the Field dimCount is less than the Mesh dimCount then the default 
! gridToFieldMap will contain zeros for the rightmost entries. A zero 
! entry in the {\tt gridToFieldMap} indicates that the particular 
! Mesh dimension will be replicating the Field across the DEs along 
! this direction. 
! \item [{[ungriddedLBound]}] 
! Lower bounds of the ungridded dimensions of the {\tt field}. 
! The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded 
! dimensions in the {\tt field}. All ungridded dimensions of the 
! {\tt field} are also undistributed. When field dimension count is 
! greater than Mesh dimension count, both ungriddedLBound and ungriddedUBound 
! must be specified. When both are specified the values are checked 
! for consistency. Note that the the ordering of 
! these ungridded dimensions is the same as their order in the {\tt field}. 
! \item [{[ungriddedUBound]}] 
! Upper bounds of the ungridded dimensions of the {\tt field}. 
! The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded 
! dimensions in the {\tt field}. All ungridded dimensions of the 
! {\tt field} are also undistributed. When field dimension count is 
! greater than Mesh dimension count, both ungriddedLBound and ungriddedUBound 
! must be specified. When both are specified the values are checked 
! for consistency. Note that the the ordering of 
! these ungridded dimensions is the same as their order in the {\tt field}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
!EOP 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh1Di1(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i1), dimension(:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB1Di1(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh1Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh2Di1(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i1), dimension(:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB2Di1(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh2Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh3Di1(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i1), dimension(:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB3Di1(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh3Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh4Di1(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i1), dimension(:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB4Di1(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh4Di1 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_GREATER_THAN_4D 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh5Di1(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i1), dimension(:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB5Di1(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh5Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh6Di1(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i1), dimension(:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB6Di1(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh6Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh7Di1(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i1), dimension(:,:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB7Di1(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh7Di1 
!---------------------------------------------------------------------------- 
 
#endif 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh1Di2(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i2), dimension(:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB1Di2(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh1Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh2Di2(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i2), dimension(:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB2Di2(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh2Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh3Di2(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i2), dimension(:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB3Di2(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh3Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh4Di2(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i2), dimension(:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB4Di2(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh4Di2 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_GREATER_THAN_4D 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh5Di2(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i2), dimension(:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB5Di2(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh5Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh6Di2(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i2), dimension(:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB6Di2(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh6Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh7Di2(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i2), dimension(:,:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB7Di2(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh7Di2 
!---------------------------------------------------------------------------- 
 
#endif 
#endif 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh1Di4(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i4), dimension(:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB1Di4(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh1Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh1Di8(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i8), dimension(:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB1Di8(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh1Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh1Dr4(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 real (ESMF_KIND_r4), dimension(:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB1Dr4(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh1Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh1Dr8(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 real (ESMF_KIND_r8), dimension(:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB1Dr8(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh1Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh2Di4(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i4), dimension(:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB2Di4(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh2Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh2Di8(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i8), dimension(:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB2Di8(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh2Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh2Dr4(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 real (ESMF_KIND_r4), dimension(:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB2Dr4(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh2Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh2Dr8(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 real (ESMF_KIND_r8), dimension(:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB2Dr8(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh2Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh3Di4(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i4), dimension(:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB3Di4(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh3Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh3Di8(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i8), dimension(:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB3Di8(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh3Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh3Dr4(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 real (ESMF_KIND_r4), dimension(:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB3Dr4(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh3Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh3Dr8(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 real (ESMF_KIND_r8), dimension(:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB3Dr8(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh3Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh4Di4(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i4), dimension(:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB4Di4(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh4Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh4Di8(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i8), dimension(:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB4Di8(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh4Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh4Dr4(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 real (ESMF_KIND_r4), dimension(:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB4Dr4(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh4Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh4Dr8(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 real (ESMF_KIND_r8), dimension(:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB4Dr8(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh4Dr8 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_GREATER_THAN_4D 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh5Di4(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i4), dimension(:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB5Di4(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh5Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh5Di8(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i8), dimension(:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB5Di8(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh5Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh5Dr4(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 real (ESMF_KIND_r4), dimension(:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB5Dr4(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh5Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh5Dr8(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 real (ESMF_KIND_r8), dimension(:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB5Dr8(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh5Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh6Di4(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i4), dimension(:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB6Di4(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh6Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh6Di8(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i8), dimension(:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB6Di8(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh6Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh6Dr4(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 real (ESMF_KIND_r4), dimension(:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB6Dr4(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh6Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh6Dr8(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 real (ESMF_KIND_r8), dimension(:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB6Dr8(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh6Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh7Di4(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i4), dimension(:,:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB7Di4(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh7Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh7Di8(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i8), dimension(:,:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB7Di8(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh7Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh7Dr4(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 real (ESMF_KIND_r4), dimension(:,:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB7Dr4(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh7Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMesh" 
 subroutine ESMF_FieldSetCommitMesh7Dr8(field, mesh, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 real (ESMF_KIND_r8), dimension(:,:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGB7Dr8(field, geombase, farray, & 
 indexflag=indexflag, copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 ungriddedLBound=ungriddedLBound, & 
 ungriddedUBound=ungriddedUBound, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 


 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMesh7Dr8 
!---------------------------------------------------------------------------- 
 
#endif 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!---------------------------------------------------------------------------- 
!BOP 
! !IROUTINE: ESMF_FieldSetCommit - Finishes creating Field from Mesh started with FieldCreateEmpty 
! 
! !INTERFACE: 
! ! Private name; call using ESMF_FieldSetCommit() 
! subroutine ESMF_FieldSetCommitMeshPtr<rank><type><kind>(field, mesh, & 
! farrayPtr, indexflag, copyflag, gridToFieldMap, rc) 
! 
! !ARGUMENTS: 
! type(ESMF_Field), intent(inout) :: field 
! type(ESMF_Mesh), intent(in) :: mesh 
! <type> (ESMF_KIND_<kind>), dimension(<rank>), pointer :: farrayPtr 
! type(ESMF_CopyFlag), intent(in), optional :: copyflag 
! integer, intent(in), optional :: gridToFieldMap(:) 
! integer, intent(inout), optional :: rc 
! 
! !DESCRIPTION: 
! This call completes an {\tt ESMF\_Field} allocated with the 
! {\tt ESMF\_FieldCreateEmpty()} call. For an example and 
! associated documentation using this method see Section 
! \ref{sec:field:usage:create_empty_setcommit}. 
! 
! The fortran data pointer inside {\tt ESMF\_Field} can be queried and deallocated when 
! copyflag is {\tt ESMF\_DATA\_REF}. Note that the {\tt ESMF\_FieldDestroy} call does not deallocate 
! the fortran data pointer in this case. This gives user more flexibility over memory management. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! The {\tt ESMF\_Field} object to be completed and 
! committed in this call. The {\tt field} will have the same dimension 
! (dimCount) as the rank of the {\tt farrayPtr}. 
! \item [mesh] 
! The {\tt ESMF\_Mesh} object to finish the Field. 
! \item [farrayPtr] 
! Native fortran data pointer to be copied/referenced in the {\tt field}. 
! The {\tt field} dimension (dimCount) will be the same as the dimCount 
! for the {\tt farrayPtr}. 
! \item [{[copyflag]}] 
! Indicates whether to copy the {\tt farrayPtr} or reference it directly. 
! For valid values see \ref{opt:copyflag}. The default is 
! {\tt ESMF\_DATA\_REF}. 
! \item [{[gridToFieldMap]}] 
! List with number of elements equal to the 
! {\tt mesh}'s dimCount. The list elements map each dimension 
! of the {\tt mesh} to a dimension in the {\tt farrayPtr} by 
! specifying the appropriate {\tt farrayPtr} dimension index. The 
! default is to map all of the {\tt mesh}'s dimensions against the 
! lowest dimensions of the {\tt farrayPtr} in sequence, i.e. 
! {\tt gridToFieldMap} = (/1,2,3,.../). 
! Unmapped {\tt farrayPtr} dimensions are undistributed Field 
! dimensions. 
! All {\tt gridToFieldMap} entries must be greater than or equal 
! to zero and smaller than or equal to the Field dimCount. It is erroneous 
! to specify the same entry multiple times unless it is zero. 
! If the Field dimCount is less than the Mesh dimCount then the default 
! gridToFieldMap will contain zeros for the rightmost entries. A zero 
! entry in the {\tt gridToFieldMap} indicates that the particular 
! Mesh dimension will be replicating the Field across the DEs along 
! this direction. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
!EOP 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr1Di1(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i1), dimension(:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr1Di1(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr1Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr2Di1(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i1), dimension(:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr2Di1(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr2Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr3Di1(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i1), dimension(:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr3Di1(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr3Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr4Di1(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i1), dimension(:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr4Di1(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr4Di1 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_GREATER_THAN_4D 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr5Di1(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i1), dimension(:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr5Di1(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr5Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr6Di1(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i1), dimension(:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr6Di1(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr6Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr7Di1(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i1), dimension(:,:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr7Di1(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr7Di1 
!---------------------------------------------------------------------------- 
 
#endif 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr1Di2(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i2), dimension(:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr1Di2(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr1Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr2Di2(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i2), dimension(:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr2Di2(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr2Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr3Di2(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i2), dimension(:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr3Di2(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr3Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr4Di2(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i2), dimension(:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr4Di2(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr4Di2 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_GREATER_THAN_4D 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr5Di2(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i2), dimension(:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr5Di2(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr5Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr6Di2(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i2), dimension(:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr6Di2(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr6Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr7Di2(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i2), dimension(:,:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr7Di2(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr7Di2 
!---------------------------------------------------------------------------- 
 
#endif 
#endif 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr1Di4(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i4), dimension(:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr1Di4(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr1Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr1Di8(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i8), dimension(:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr1Di8(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr1Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr1Dr4(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 real (ESMF_KIND_r4), dimension(:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr1Dr4(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr1Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr1Dr8(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 real (ESMF_KIND_r8), dimension(:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr1Dr8(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr1Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr2Di4(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i4), dimension(:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr2Di4(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr2Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr2Di8(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i8), dimension(:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr2Di8(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr2Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr2Dr4(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 real (ESMF_KIND_r4), dimension(:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr2Dr4(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr2Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr2Dr8(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 real (ESMF_KIND_r8), dimension(:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr2Dr8(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr2Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr3Di4(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i4), dimension(:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr3Di4(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr3Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr3Di8(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i8), dimension(:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr3Di8(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr3Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr3Dr4(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 real (ESMF_KIND_r4), dimension(:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr3Dr4(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr3Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr3Dr8(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 real (ESMF_KIND_r8), dimension(:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr3Dr8(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr3Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr4Di4(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i4), dimension(:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr4Di4(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr4Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr4Di8(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i8), dimension(:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr4Di8(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr4Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr4Dr4(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 real (ESMF_KIND_r4), dimension(:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr4Dr4(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr4Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr4Dr8(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 real (ESMF_KIND_r8), dimension(:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr4Dr8(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr4Dr8 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_GREATER_THAN_4D 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr5Di4(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i4), dimension(:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr5Di4(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr5Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr5Di8(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i8), dimension(:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr5Di8(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr5Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr5Dr4(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 real (ESMF_KIND_r4), dimension(:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr5Dr4(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr5Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr5Dr8(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 real (ESMF_KIND_r8), dimension(:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr5Dr8(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr5Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr6Di4(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i4), dimension(:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr6Di4(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr6Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr6Di8(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i8), dimension(:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr6Di8(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr6Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr6Dr4(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 real (ESMF_KIND_r4), dimension(:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr6Dr4(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr6Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr6Dr8(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 real (ESMF_KIND_r8), dimension(:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr6Dr8(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr6Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr7Di4(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i4), dimension(:,:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr7Di4(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr7Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr7Di8(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 integer (ESMF_KIND_i8), dimension(:,:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr7Di8(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr7Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr7Dr4(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 real (ESMF_KIND_r4), dimension(:,:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr7Dr4(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr7Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitMeshPtr" 
 subroutine ESMF_FieldSetCommitMeshPtr7Dr8(field, mesh, & 
 farrayPtr, copyflag, gridToFieldMap, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_Mesh) :: mesh 
 real (ESMF_KIND_r8), dimension(:,:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer :: localrc 
 type(ESMF_GeomBase) :: geombase 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, mesh, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_MeshGetInit,mesh,rc) 

 geombase=ESMF_GeomBaseCreate(mesh,rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Do General GeomBase SetCommit 
 call ESMF_FieldSetCommitGBPtr7Dr8(field, geombase, farrayPtr, & 
 copyflag=copyflag, gridToFieldMap=gridToFieldMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitMeshPtr7Dr8 
!---------------------------------------------------------------------------- 
 
#endif 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!---------------------------------------------------------------------------- 
!BOPI 
! !IROUTINE: ESMF_FieldSetCommit - Finishes creating Field started with FieldCreateEmpty 
! 
! !INTERFACE: 
! ! Private name; call using ESMF_FieldSetCommit() 
! subroutine ESMF_FieldSetCommitGB<rank><type><kind>(field, geombase, & 
! farray, indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
! ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 
! 
! !ARGUMENTS: 
! type(ESMF_Field), intent(inout) :: field 
! type(ESMF_GeomBase), intent(in) :: geombase 
! <type> (ESMF_KIND_<kind>), dimension(<rank>), target :: farray 
! type(ESMF_IndexFlag), intent(in) :: indexflag 
! type(ESMF_CopyFlag), intent(in), optional :: copyflag 
! integer, intent(in), optional :: gridToFieldMap(:) 
! integer, intent(in), optional :: ungriddedLBound(:) 
! integer, intent(in), optional :: ungriddedUBound(:) 
! integer, intent(in), optional :: maxHaloLWidth(:) 
! integer, intent(in), optional :: maxHaloUWidth(:) 
! integer, intent(inout), optional :: rc 
! 
! !DESCRIPTION: 
! This call completes an {\tt ESMF\_Field} allocated with the 
! {\tt ESMF\_FieldCreateEmpty()} call. For an example and 
! associated documentation using this method see Section 
! \ref{sec:field:usage:create_empty_setcommit}. 
! 
! The fortran data pointer inside {\tt ESMF\_Field} can be queried but deallocating 
! the retrieved data pointer is not allowed. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! The {\tt ESMF\_Field} object to be completed and 
! committed in this call. The {\tt field} will have the same dimension 
! (dimCount) as the rank of the {\tt farray}. 
! \item [geombase] 
! The {\tt ESMF\_GeomBase} object to finish the Field. 
! \item [farray] 
! Native fortran data array to be copied/referenced in the {\tt field}. 
! The {\tt field} dimension (dimCount) will be the same as the dimCount 
! for the {\tt farray}. 
! \item [indexflag] 
! Indicate how DE-local indices are defined. See section 
! \ref{opt:indexflag} for a list of valid indexflag options. 
! \item [{[copyflag]}] 
! Indicates whether to copy the {\tt farray} or reference it directly. 
! For valid values see \ref{opt:copyflag}. The default is 
! {\tt ESMF\_DATA\_REF}. 
! \item [{[gridToFieldMap]}] 
! List with number of elements equal to the 
! {\tt geombase}'s dimCount. The list elements map each dimension 
! of the {\tt geombase} to a dimension in the {\tt farray} by 
! specifying the appropriate {\tt farray} dimension index. The 
! default is to map all of the {\tt geombase}'s dimensions against the 
! lowest dimensions of the {\tt farray} in sequence, i.e. 
! {\tt gridToFieldMap} = (/1,2,3,.../). 
! Unmapped {\tt farray} dimensions are undistributed Field 
! dimensions. 
! All {\tt gridToFieldMap} entries must be greater than or equal 
! to zero and smaller than or equal to the Field dimCount. It is erroneous 
! to specify the same entry multiple times unless it is zero. 
! If the Field dimCount is less than the Grid dimCount then the default 
! gridToFieldMap will contain zeros for the rightmost entries. A zero 
! entry in the {\tt gridToFieldMap} indicates that the particular 
! Grid dimension will be replicating the Field across the DEs along 
! this direction. 
! \item [{[ungriddedLBound]}] 
! Lower bounds of the ungridded dimensions of the {\tt field}. 
! The number of elements in the {\tt ungriddedLBound} is equal to the number of ungridded 
! dimensions in the {\tt field}. All ungridded dimensions of the 
! {\tt field} are also undistributed. When field dimension count is 
! greater than grid dimension count, both ungriddedLBound and ungriddedUBound 
! must be specified. When both are specified the values are checked 
! for consistency. Note that the the ordering of 
! these ungridded dimensions is the same as their order in the {\tt field}. 
! \item [{[ungriddedUBound]}] 
! Upper bounds of the ungridded dimensions of the {\tt field}. 
! The number of elements in the {\tt ungriddedUBound} is equal to the number of ungridded 
! dimensions in the {\tt field}. All ungridded dimensions of the 
! {\tt field} are also undistributed. When field dimension count is 
! greater than grid dimension count, both ungriddedLBound and ungriddedUBound 
! must be specified. When both are specified the values are checked 
! for consistency. Note that the the ordering of 
! these ungridded dimensions is the same as their order in the {\tt field}. 
! \item [{[maxHaloLWidth]}] 
! Lower bound of halo region. The size of this array is the number 
! of gridded dimensions in the {\tt field}. However, ordering of the elements 
! needs to be the same as they appear in the {\tt field}. Values default 
! to 0. If values for maxHaloLWidth are specified they must be reflected in 
! the size of the {\tt field}. That is, for each gridded dimension the 
! {\tt field} size should be max( {\tt maxHaloLWidth} + {\tt maxHaloUWidth} 
! + {\tt computationalCount}, {\tt exclusiveCount} ). Although the halo operation is not 
! implemented, the {\tt minHaloLWidth} is checked for validity and stored 
! in preparation for the implementation of the halo method. 
! HALO OPERATION NOT IMPLEMENTED 
! \item [{[maxHaloUWidth]}] 
! Upper bound of halo region. The size of this array is the number 
! of gridded dimensions in the {\tt field}. However, ordering of the elements 
! needs to be the same as they appear in the {\tt field}. Values default 
! to 0. If values for maxHaloUWidth are specified they must be reflected in 
! the size of the {\tt field}. That is, for each gridded dimension the 
! {\tt field} size should max( {\tt maxHaloLWidth} + {\tt maxHaloUWidth} 
! + {\tt computationalCount}, {\tt exclusiveCount} ). Although the halo operation is not 
! implemented, the {\tt maxHaloUWidth} is checked for validity and stored 
! in preparation for the implementation of the halo method. 
! HALO OPERATION NOT IMPLEMENTED 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
!EOPI 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB1Di1(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i1), dimension(:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i1), dimension(:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 1 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB1Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB2Di1(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i1), dimension(:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i1), dimension(:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 2 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB2Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB3Di1(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i1), dimension(:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i1), dimension(:,:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 3 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB3Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB4Di1(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i1), dimension(:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i1), dimension(:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 4 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB4Di1 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_GREATER_THAN_4D 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB5Di1(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i1), dimension(:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i1), dimension(:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 5 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB5Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB6Di1(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i1), dimension(:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i1), dimension(:,:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 6 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB6Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB7Di1(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i1), dimension(:,:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i1), dimension(:,:,:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 7 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB7Di1 
!---------------------------------------------------------------------------- 
 
#endif 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB1Di2(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i2), dimension(:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i2), dimension(:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 1 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB1Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB2Di2(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i2), dimension(:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i2), dimension(:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 2 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB2Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB3Di2(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i2), dimension(:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i2), dimension(:,:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 3 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB3Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB4Di2(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i2), dimension(:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i2), dimension(:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 4 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB4Di2 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_GREATER_THAN_4D 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB5Di2(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i2), dimension(:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i2), dimension(:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 5 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB5Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB6Di2(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i2), dimension(:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i2), dimension(:,:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 6 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB6Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB7Di2(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i2), dimension(:,:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i2), dimension(:,:,:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 7 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB7Di2 
!---------------------------------------------------------------------------- 
 
#endif 
#endif 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB1Di4(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i4), dimension(:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i4), dimension(:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 1 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB1Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB1Di8(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i8), dimension(:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i8), dimension(:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 1 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB1Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB1Dr4(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 real (ESMF_KIND_r4), dimension(:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 real (ESMF_KIND_r4), dimension(:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 1 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB1Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB1Dr8(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 real (ESMF_KIND_r8), dimension(:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 real (ESMF_KIND_r8), dimension(:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 1 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB1Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB2Di4(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i4), dimension(:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i4), dimension(:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 2 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB2Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB2Di8(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i8), dimension(:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i8), dimension(:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 2 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB2Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB2Dr4(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 real (ESMF_KIND_r4), dimension(:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 real (ESMF_KIND_r4), dimension(:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 2 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB2Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB2Dr8(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 real (ESMF_KIND_r8), dimension(:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 real (ESMF_KIND_r8), dimension(:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 2 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB2Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB3Di4(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i4), dimension(:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i4), dimension(:,:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 3 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB3Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB3Di8(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i8), dimension(:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i8), dimension(:,:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 3 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB3Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB3Dr4(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 real (ESMF_KIND_r4), dimension(:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 real (ESMF_KIND_r4), dimension(:,:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 3 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB3Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB3Dr8(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 real (ESMF_KIND_r8), dimension(:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 real (ESMF_KIND_r8), dimension(:,:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 3 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB3Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB4Di4(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i4), dimension(:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i4), dimension(:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 4 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB4Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB4Di8(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i8), dimension(:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i8), dimension(:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 4 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB4Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB4Dr4(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 real (ESMF_KIND_r4), dimension(:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 real (ESMF_KIND_r4), dimension(:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 4 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB4Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB4Dr8(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 real (ESMF_KIND_r8), dimension(:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 real (ESMF_KIND_r8), dimension(:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 4 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB4Dr8 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_GREATER_THAN_4D 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB5Di4(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i4), dimension(:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i4), dimension(:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 5 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB5Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB5Di8(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i8), dimension(:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i8), dimension(:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 5 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB5Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB5Dr4(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 real (ESMF_KIND_r4), dimension(:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 real (ESMF_KIND_r4), dimension(:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 5 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB5Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB5Dr8(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 real (ESMF_KIND_r8), dimension(:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 real (ESMF_KIND_r8), dimension(:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 5 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB5Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB6Di4(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i4), dimension(:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i4), dimension(:,:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 6 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB6Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB6Di8(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i8), dimension(:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i8), dimension(:,:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 6 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB6Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB6Dr4(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 real (ESMF_KIND_r4), dimension(:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 real (ESMF_KIND_r4), dimension(:,:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 6 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB6Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB6Dr8(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 real (ESMF_KIND_r8), dimension(:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 real (ESMF_KIND_r8), dimension(:,:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 6 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB6Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB7Di4(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i4), dimension(:,:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i4), dimension(:,:,:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 7 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB7Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB7Di8(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i8), dimension(:,:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i8), dimension(:,:,:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 7 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB7Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB7Dr4(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 real (ESMF_KIND_r4), dimension(:,:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 real (ESMF_KIND_r4), dimension(:,:,:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 7 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB7Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGB" 
 subroutine ESMF_FieldSetCommitGB7Dr8(field, geombase, farray, & 
 indexflag, copyflag, gridToFieldMap, ungriddedLBound, & 
 ungriddedUBound, maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 real (ESMF_KIND_r8), dimension(:,:,:,:,:,:,:), target :: farray 
 type(ESMF_IndexFlag), intent(in) :: indexflag 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: ungriddedLBound(:) 
 integer, intent(in), optional :: ungriddedUBound(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 real (ESMF_KIND_r8), dimension(:,:,:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j, count 
 integer :: memDimCount, fieldDimCount, fieldUngriddedDimCount 
 integer :: gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: ungriddedIndex(ESMF_MAXDIM) 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localUngriddedLBound (ESMF_MAXDIM) 
 integer :: localUngriddedUBound (ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 logical :: isGridded(ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: g_indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farray are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=g_indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if(.not. (indexflag .eq. g_indexflag)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- user specified indexflag must be identical with Grid indexflag", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farray 
 if(.not. associated(fpointer,farray)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farray is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Check the size of the native array. 
 memDimCount = 7 

 ! Error Check Input 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 

 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farray rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
! refer to ticket 1888180 
! if(fieldDimCount .gt. gridDimCount_norep) then 
! if( (.not. present(ungriddedLBound)) .or. & 
! (.not. present(ungriddedUBound)) ) then 
! call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
! "- ungridded bounds must be present when Field has ungridded dimension(s)", & 
! ESMF_CONTEXT, rc) 
! return 
! endif 
! endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUngriddedDimCount = fieldDimCount-gridDimCount + grid_repdimcount 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 ! Error Check Input 
 if (present(ungriddedLBound)) then 
 if (size(ungriddedLBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedLBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(ungriddedUBound)) then 
 if (size(ungriddedUBound) .ne. fieldUngriddedDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- ungriddedUBound size must equal to array_rank-grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 ! Here we get the lbounds and ubounds for ungridded 
 ! dimensions from the native array, if it is not input 
 ! through the argument list. First we need to set up 
 ! an index array that holds the ungridded dimensions of 
 ! the native array. 

 ! Since we are saving the ungriddedIndex calculate it even 
 ! if ungridded bounds are present 

 ! Figure out which dims are ungridded 
 isGridded = .false. 
 do i=1, gridDimCount 
 if(localGridToFieldMap(i) /= 0) isGridded(localGridToFieldMap(i)) = .true. 
 enddo 

 ! Use ungridded info to figure out the map from ungridded to field dims 
 count=1 
 do i=1,fieldDimCount 
 if (.not. isGridded(i)) then 
 ungriddedIndex(count)=i 
 count=count+1 
 endif 
 enddo 

 ! set Array ungridded bounds depending on what user provides
 if (present(ungriddedLBound)) then 
 if(present(ungriddedUBound)) then 
 ! Both present so copy 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! Copy lower bound and make upper bound high enough to fit 
 localUngriddedLBound(1:fieldUngriddedDimCount) = & 
 ungriddedLBound(1:fieldUngriddedDimCount) 
 do i=1, fieldUngriddedDimCount 
 localUngriddedUBound(i) = ungriddedLBound(i)+ & 
 size (farray,ungriddedIndex(i))-1 
 enddo 
 endif 
 else 
 if(present(ungriddedUBound)) then 
 ! Copy upper bound and make lower bound low enough to fit 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = ungriddedUBound(i)- & 
 size (farray,ungriddedIndex(i))+1 
 enddo 
 localUngriddedUBound(1:fieldUngriddedDimCount) = & 
 ungriddedUBound(1:fieldUngriddedDimCount) 
 else 
 ! No user info copy array bounds 
 ! Note: assumed shape bounds will be 1...size 
 do i=1, fieldUngriddedDimCount 
 localUngriddedLBound(i) = lbound(farray,ungriddedIndex(i)) 
 localUngriddedUBound(i) = ubound(farray,ungriddedIndex(i)) 
 enddo 
 endif 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUngriddedDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 ungriddedLBound=localUngriddedLBound (1:fieldUngriddedDimCount), & 
 ungriddedUBound=localUngriddedUBound (1:fieldUngriddedDimCount), & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farray, distgrid=distgrid, & 
 indexflag=indexflag, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 undistLBound=undistLBound(1:fieldUndistDimCount), & 
 undistUBound=undistUBound(1:fieldUndistDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%ungriddedLBound(1:fieldUngriddedDimCount) = & 
 localUngriddedLBound(1:fieldUngriddedDimCount) 
 field%ftypep%ungriddedUBound(1:fieldUngriddedDimCount) = & 
 localUngriddedUBound(1:fieldUngriddedDimCount) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUngriddedDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGB7Dr8 
!---------------------------------------------------------------------------- 
 
#endif 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!---------------------------------------------------------------------------- 
!BOPI 
! !IROUTINE: ESMF_FieldSetCommit - Finishes creating Field started with FieldCreateEmpty 
! 
! !INTERFACE: 
! ! Private name; call using ESMF_FieldSetCommit() 
! subroutine ESMF_FieldSetCommitGBPtr<rank><type><kind>(field, geombase, & 
! farrayPtr, copyflag, gridToFieldMap, & 
! maxHaloLWidth, maxHaloUWidth, rc) 
! 
! !ARGUMENTS: 
! type(ESMF_Field), intent(inou) :: field 
! type(ESMF_GeomBase), intent(in) :: geombase 
! <type> (ESMF_KIND_<kind>), dimension(<rank>), pointer :: farrayPtr 
! type(ESMF_CopyFlag), intent(in), optional :: copyflag 
! integer, intent(in), optional :: gridToFieldMap(:) 
! integer, intent(in), optional :: maxHaloLWidth(:) 
! integer, intent(in), optional :: maxHaloUWidth(:) 
! integer, intent(inout), optional :: rc 
! 
! !DESCRIPTION: 
! This call completes an {\tt ESMF\_Field} allocated with the 
! {\tt ESMF\_FieldCreateEmpty()} call. For an example and 
! associated documentation using this method see Section 
! \ref{sec:field:usage:create_empty_setcommit}. 
! 
! The fortran data pointer inside {\tt ESMF\_Field} can be queried and deallocated when 
! copyflag is {\tt ESMF\_DATA\_REF}. Note that the {\tt ESMF\_FieldDestroy} call does not deallocate 
! the fortran data pointer in this case. This gives user more flexibility over memory management. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! The {\tt ESMF\_Field} object to be completed and 
! committed in this call. The {\tt field} will have the same dimension 
! (dimCount) as the rank of the {\tt farrayPtr}. 
! \item [geombase] 
! The {\tt ESMF\_GeomBase} object to finish the Field. The dimCount of the 
! GeomBase must be smaller than or equal to the rank of the {\tt farrayPtr}. 
! \item [farrayPtr] 
! Native fortran data pointer to be copied/referenced in the {\tt field}. 
! The {\tt field} dimension (dimCount) will be the same as the dimCount 
! for the {\tt farrayPtr}. 
! \item [{[copyflag]}] 
! Indicates whether to copy the {\tt farrayPtr} or reference it directly. 
! For valid values see \ref{opt:copyflag}. The default is 
! {\tt ESMF\_DATA\_REF}. 
! \item [{[gridToFieldMap]}] 
! List with number of elements equal to the 
! {\tt geombase}'s dimCount. The list elements map each dimension 
! of the {\tt geombase} to a dimension in the {\tt farrayPtr} by 
! specifying the appropriate {\tt farrayPtr} dimension index. The 
! default is to map all of the {\tt geombase}'s dimensions against the 
! lowest dimensions of the {\tt farrayPtr} in sequence, i.e. 
! {\tt gridToFieldMap} = (/1,2,3,.../). 
! Unmapped {\tt farrayPtr} dimensions are undistributed Field 
! dimensions. 
! All {\tt gridToFieldMap} entries must be greater than or equal 
! to zero and smaller than or equal to the Field dimCount. It is erroneous 
! to specify the same entry multiple times unless it is zero. 
! If the Field dimCount is less than the Grid dimCount then the default 
! gridToFieldMap will contain zeros for the rightmost entries. A zero 
! entry in the {\tt gridToFieldMap} indicates that the particular 
! Grid dimension will be replicating the Field across the DEs along 
! this direction. 
! \item [{[maxHaloLWidth]}] 
! Lower bound of halo region. The size of this array is the number 
! of gridded dimensions in the {\tt field}. However, ordering of the elements 
! needs to be the same as they appear in the {\tt field}. Values default 
! to 0. If values for maxHaloLWidth are specified they must be reflected in 
! the size of the {\tt field}. That is, for each gridded dimension the 
! {\tt field} size should be max( {\tt maxHaloLWidth} + {\tt maxHaloUWidth} 
! + {\tt computationalCount}, {\tt exclusiveCount} ). Although the halo operation is not 
! implemented, the {\tt minHaloLWidth} is checked for validity and stored 
! in preparation for the implementation of the halo method. 
! HALO OPERATION NOT IMPLEMENTED 
! \item [{[maxHaloUWidth]}] 
! Upper bound of halo region. The size of this array is the number 
! of gridded dimensions in the {\tt field}. However, ordering of the elements 
! needs to be the same as they appear in the {\tt field}. Values default 
! to 0. If values for maxHaloUWidth are specified they must be reflected in 
! the size of the {\tt field}. That is, for each gridded dimension the 
! {\tt field} size should max( {\tt maxHaloLWidth} + {\tt maxHaloUWidth} 
! + {\tt computationalCount}, {\tt exclusiveCount} ). Although the halo operation is not 
! implemented, the {\tt maxHaloUWidth} is checked for validity and stored 
! in preparation for the implementation of the halo method. 
! HALO OPERATION NOT IMPLEMENTED 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
!EOPI 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr1Di1(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i1), dimension(:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i1), dimension(:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 1 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr1Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr2Di1(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i1), dimension(:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i1), dimension(:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 2 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr2Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr3Di1(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i1), dimension(:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i1), dimension(:,:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 3 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr3Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr4Di1(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i1), dimension(:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i1), dimension(:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 4 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr4Di1 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_GREATER_THAN_4D 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr5Di1(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i1), dimension(:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i1), dimension(:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 5 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr5Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr6Di1(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i1), dimension(:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i1), dimension(:,:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 6 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr6Di1 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr7Di1(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i1), dimension(:,:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i1), dimension(:,:,:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 7 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr7Di1 
!---------------------------------------------------------------------------- 
 
#endif 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr1Di2(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i2), dimension(:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i2), dimension(:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 1 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr1Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr2Di2(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i2), dimension(:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i2), dimension(:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 2 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr2Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr3Di2(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i2), dimension(:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i2), dimension(:,:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 3 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr3Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr4Di2(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i2), dimension(:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i2), dimension(:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 4 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr4Di2 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_GREATER_THAN_4D 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr5Di2(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i2), dimension(:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i2), dimension(:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 5 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr5Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr6Di2(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i2), dimension(:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i2), dimension(:,:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 6 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr6Di2 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr7Di2(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i2), dimension(:,:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i2), dimension(:,:,:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 7 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr7Di2 
!---------------------------------------------------------------------------- 
 
#endif 
#endif 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr1Di4(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i4), dimension(:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i4), dimension(:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 1 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr1Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr1Di8(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i8), dimension(:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i8), dimension(:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 1 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr1Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr1Dr4(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 real (ESMF_KIND_r4), dimension(:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 real (ESMF_KIND_r4), dimension(:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 1 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr1Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr1Dr8(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 real (ESMF_KIND_r8), dimension(:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 real (ESMF_KIND_r8), dimension(:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 1 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr1Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr2Di4(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i4), dimension(:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i4), dimension(:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 2 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr2Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr2Di8(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i8), dimension(:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i8), dimension(:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 2 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr2Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr2Dr4(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 real (ESMF_KIND_r4), dimension(:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 real (ESMF_KIND_r4), dimension(:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 2 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr2Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr2Dr8(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 real (ESMF_KIND_r8), dimension(:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 real (ESMF_KIND_r8), dimension(:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 2 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr2Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr3Di4(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i4), dimension(:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i4), dimension(:,:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 3 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr3Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr3Di8(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i8), dimension(:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i8), dimension(:,:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 3 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr3Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr3Dr4(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 real (ESMF_KIND_r4), dimension(:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 real (ESMF_KIND_r4), dimension(:,:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 3 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr3Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr3Dr8(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 real (ESMF_KIND_r8), dimension(:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 real (ESMF_KIND_r8), dimension(:,:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 3 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr3Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr4Di4(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i4), dimension(:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i4), dimension(:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 4 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr4Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr4Di8(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i8), dimension(:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i8), dimension(:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 4 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr4Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr4Dr4(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 real (ESMF_KIND_r4), dimension(:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 real (ESMF_KIND_r4), dimension(:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 4 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr4Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr4Dr8(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 real (ESMF_KIND_r8), dimension(:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 real (ESMF_KIND_r8), dimension(:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 4 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr4Dr8 
!---------------------------------------------------------------------------- 
 
#ifndef ESMF_NO_GREATER_THAN_4D 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr5Di4(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i4), dimension(:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i4), dimension(:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 5 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr5Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr5Di8(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i8), dimension(:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i8), dimension(:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 5 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr5Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr5Dr4(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 real (ESMF_KIND_r4), dimension(:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 real (ESMF_KIND_r4), dimension(:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 5 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr5Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr5Dr8(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 real (ESMF_KIND_r8), dimension(:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 real (ESMF_KIND_r8), dimension(:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 5 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr5Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr6Di4(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i4), dimension(:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i4), dimension(:,:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 6 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr6Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr6Di8(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i8), dimension(:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i8), dimension(:,:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 6 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr6Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr6Dr4(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 real (ESMF_KIND_r4), dimension(:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 real (ESMF_KIND_r4), dimension(:,:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 6 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr6Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr6Dr8(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 real (ESMF_KIND_r8), dimension(:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 real (ESMF_KIND_r8), dimension(:,:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 6 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr6Dr8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr7Di4(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i4), dimension(:,:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i4), dimension(:,:,:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 7 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr7Di4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr7Di8(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 integer (ESMF_KIND_i8), dimension(:,:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 integer (ESMF_KIND_i8), dimension(:,:,:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 7 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr7Di8 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr7Dr4(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 real (ESMF_KIND_r4), dimension(:,:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 real (ESMF_KIND_r4), dimension(:,:,:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 7 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr7Dr4 
!---------------------------------------------------------------------------- 
 
!---------------------------------------------------------------------------- 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_FieldSetCommitGBPtr" 
 subroutine ESMF_FieldSetCommitGBPtr7Dr8(field, geombase, farrayPtr, & 
 copyflag, gridToFieldMap, & 
 maxHaloLWidth, maxHaloUWidth, rc) 

 ! input arguments 
 type(ESMF_Field) :: field 
 type(ESMF_GeomBase) :: geombase 
 real (ESMF_KIND_r8), dimension(:,:,:,:,:,:,:), pointer :: farrayPtr 
 type(ESMF_CopyFlag), intent(in), optional :: copyflag 
 integer, intent(in), optional :: gridToFieldMap(:) 
 integer, intent(in), optional :: maxHaloLWidth(:) 
 integer, intent(in), optional :: maxHaloUWidth(:) 
 integer, intent(out), optional :: rc 
 ! local variables 
 real (ESMF_KIND_r8), dimension(:,:,:,:,:,:,:), pointer :: fpointer 
 integer :: localrc, i, j 
 integer :: fieldDimCount 
 integer :: memDimCount, gridDimCount, gridDimCount_norep 
 integer :: grid_repdimcount 
 integer :: elementCount 
 integer :: distgridToArrayMap (ESMF_MAXDIM) 
 integer :: undistLBound(ESMF_MAXDIM), undistUBound(ESMF_MAXDIM) 
 integer :: localGridToFieldMap (ESMF_MAXDIM) 
 integer :: localMaxHaloLWidth (ESMF_MAXDIM) 
 integer :: localMaxHaloUWidth (ESMF_MAXDIM) 
 integer :: distgridToGridMap(ESMF_MAXDIM) 
 type(ESMF_Array) :: array 
 type(ESMF_DistGrid) :: distgrid 
 integer :: fieldUndistDimCount 
 logical :: flipflop(ESMF_MAXDIM) 
 type(ESMF_IndexFlag) :: indexflag 
 logical :: found 
 type(ESMF_GridDecompType) :: decompType 
 type(ESMF_GeomType) :: geomType 
 type(ESMF_Grid) :: grid 
 integer :: distgridDimCount, distgridDimCount_norep, arbdim 

 if (present(rc)) then 
 rc = ESMF_RC_NOT_IMPL 
 endif 
 localrc = ESMF_RC_NOT_IMPL 

 ! make sure field, grid, farrayPtr are properly initialized 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_GeomBaseGetInit,geombase,rc) 

 ! Get number of grid dimensions, number 
 ! of distributed grid dimensions, distgrid, 
 ! number of ungridded Field dimensions, 
 ! and number of undistributed Field Dimensions 
 call ESMF_GeomBaseGet(geombase, dimCount=gridDimCount, & 
 distgridToGridMap=distgridToGridMap, & 
 distgrid=distgrid, indexflag=indexflag, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 call ESMF_DistGridGet(distgrid, localDe=0, elementCount=elementCount, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (elementCount > 0) then 
 ! The following use of fptr is a bit of trickery to get all F90 
 ! compilers to cooperate. For some compilers the associated() test 
 ! will return .false. for farray of size 0. Some of those compilers 
 ! will produce a run-time error in size(fptr). Other compilers will 
 ! return .true. for the associated() test but return 0 in size(). 
 fpointer => farrayPtr 
 if(.not. associated(fpointer,farrayPtr)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 if (size(fpointer)==0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "- farrayPtr is not associated with memory allocation)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 ! Check if geombase is a grid, if so, check if it is arbitrary 
 decompType = ESMF_GRID_NONARBITRARY 
 call ESMF_GeomBaseGet(geombase, geomType=geomType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 
 if (geomType .eq. ESMF_GEOMTYPE_GRID) then 
 call ESMF_GeomBaseGet(geombase, grid=grid, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 call ESMF_GridGetDecompType(grid, decompType, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 ! Error Check Input 
 ! And count the number of replicated dimensions in the Grid 
 grid_repdimcount = 0 
 if (present(gridToFieldMap)) then 
 if (size(gridToFieldMap) .ne. gridDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- gridToFieldMap size must equal to grid_rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 do i = 1, gridDimCount 
 if(gridToFieldMap(i) == 0) grid_repdimcount = grid_repdimcount + 1 
 enddo 
 endif 
 gridDimCount_norep = gridDimCount - grid_repdimcount 
 if (present(gridToFieldMap)) then 
 localGridToFieldMap(1:gridDimCount) = & 
 gridToFieldMap (1:gridDimCount) 
 else 
 do i = 1, gridDimCount 
 localGridToFieldMap(i) = i 
 enddo 
 endif 

 ! Check the size of the native array. 
 memDimCount = 7 

 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 fieldDimCount = memDimCount 
 else 
 call ESMF_GridGet(grid, distgridToGridMap=distgridToGridMap, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 ! find out how many grid dimensions are arbitrarily distributed and calculate 
 ! fieldDimCount accordingly 
 arbdim = 0 
 do i=1,gridDimCount 
 if (distgridToGridMap(i) .ne. 0) arbdim = arbdim+1 
 enddo 
 fieldDimCount = memDimCount + arbdim - 1 
 
 ! If there is any replicated dimension, check if any of the arb. dimensions are replicated. 
 ! If one arb dimension is replicated, all the arb. dimensions have to be replicated 
 if (grid_repdimcount .ne. 0) then 
 do i = 1,gridDimCount 
 if(localGridToFieldMap(i) == 0) then 
 found = .false. 
 do j=1,arbdim 
 if (distgridToGridMap(j) .eq. i) found = .true. 
 enddo 
 if (found) then 
 ! one arb.dimension is a replicated dimension, check if other arb dimensions are 
 ! also replicated 
 do j=1,arbdim 
 if (distgridToGridMap(j) .ne. i) then 
 if (localGridToFieldMap(distgridToGridMap(j)) .ne. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- Arb. grid dimensions have to be either all replicated or not replicated", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 enddo 
 ! all arb. dimension are replication, jump out of the first do loop 
 ! fieldDimCount should be the same as the memDimCount 
 fieldDimCount = memDimCount 
 exit 
 endif 
 endif 
 enddo 
 endif 
 endif 

 if(fieldDimCount .lt. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- farrayPtr rank must be greater than or equal to grid rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 

 ! ungridded dimensions plus replicated dimensions 
 fieldUndistDimCount = fieldDimCount-gridDimCount + grid_repdimcount 

 if (present(maxHaloLWidth)) then 
 if (size(maxHaloLWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloLWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(maxHaloUWidth)) then 
 if (size(maxHaloUWidth) .ne. gridDimCount_norep) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "- maxHaloUWidth must equal to gridded dimCount", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 ! gridToFieldMap elements must be in range 0...fieldRank and unique 
 ! algorithm to check element uniqueness: 
 ! run time: O(ESMF_MAXDIM) 
 ! memory: O(2*ESMF_MAXDIM) 
 ! or O(ESMF_MAXDIM+ESMF_MAXDIM/sizeof(integer)) with bitvector 
 flipflop = .false. 
 do i = 1, gridDimCount 
 if(localGridToFieldMap(i) .lt. 0 .or. & 
 localGridToFieldMap(i) .gt. fieldDimCount) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be within range 0...array rank", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if(localGridToFieldMap(i) /= 0) then 
 if(flipflop(localGridToFieldMap(i))) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_VALUE, & 
 "- gridToFieldMap element must be unique", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 flipflop(localGridToFieldMap(i)) = .true. 
 endif 
 enddo 

 if(present(maxHaloLWidth)) then 
 localMaxHaloLWidth(1:gridDimCount_norep) = & 
 maxHaloLWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloLWidth = 0 
 endif 

 if(present(maxHaloUWidth)) then 
 localMaxHaloUWidth(1:gridDimCount_norep) = & 
 maxHaloUWidth (1:gridDimCount_norep) 
 else 
 localMaxHaloUWidth = 0 
 endif 

 call ESMF_DistGridGet(distgrid, dimCount=distgridDimCount, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 distgridDimCount_norep = memDimCount - fieldUndistDimCount 

 ! The undistributed info from the Grid needs to be 
 ! combined with the ungridded info from the Field in order 
 ! to create the Array for the Field. 
 call ESMF_GeomBaseGetArrayInfo(geombase, & 
 gridToFieldMap=localGridToFieldMap, & 
 distgridToArrayMap=distgridToArrayMap, & 
 undistLBound=undistLBound, undistUBound=undistUBound, & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 ! Create Array with undistributed dimensions 
 if (decompType .eq. ESMF_GRID_NONARBITRARY) then 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 totalLWidth=localMaxHaloLWidth(1:gridDimCount_norep), & 
 totalUWidth=localMaxHaloUWidth(1:gridDimCount_norep), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 else 
 array = ESMF_ArrayCreate(farrayPtr, distgrid=distgrid, copyflag=copyflag, & 
 distgridToArrayMap=distgridToArrayMap (1:distgridDimCount), & 
 rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 endif 

 field%ftypep%array = array 

 ! set array_internal to .true. because field%array is internal 
 field%ftypep%array_internal = .true. 

 ! Should call a common FieldSetCommitPtrConstructor here instead 
 ! of just setting things up ourselves 
 ! (The field Sets were all moved here in preparation for this) 
 field%ftypep%gridToFieldMap(1:gridDimCount) = & 
 localGridToFieldMap(1:gridDimCount) 
 field%ftypep%maxHaloLWidth(1:gridDimCount_norep) = & 
 localMaxHaloLWidth (1:gridDimCount_norep) 
 field%ftypep%maxHaloUWidth(1:gridDimCount_norep) = & 
 localMaxHaloUWidth (1:gridDimCount_norep) 
 field%ftypep%datastatus = ESMF_STATUS_READY 
 field%ftypep%geombase = geombase 
 field%ftypep%gridstatus = ESMF_STATUS_READY 
 call ESMF_BaseSetStatus(field%ftypep%base, ESMF_STATUS_READY, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 
 field%ftypep%dimCount = gridDimCount_norep + fieldUndistDimCount 

 call ESMF_FieldValidate(field, rc=localrc) 
 if (ESMF_LogMsgFoundError(localrc, & 
 ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rc)) return 

 if (present(rc)) rc = ESMF_SUCCESS 
 end subroutine ESMF_FieldSetCommitGBPtr7Dr8 
!---------------------------------------------------------------------------- 
 
#endif 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

end module ESMF_FieldSetCoMod
